// import express from 'express';
// import cors from 'cors';
// import { WebSocketServer } from 'ws';
// import { createServer } from 'http';
// import { db, initializeDatabase } from '../db';
// import { projects, files } from '../db/schema';
// import { eq, and } from 'drizzle-orm';
// import path from "path";


// const app = express();
// const server = createServer(app);
// const PORT = 9999;

// app.use(cors({
//   origin: ['http://localhost:5173', 'http://localhost:3000'], // bolt.diy dev servers
//   credentials: true,
//   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
//   allowedHeaders: ['Content-Type', 'Authorization']
// }));

// app.use(express.json({ limit: '50mb' }));
// app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// // Health check endpoint
// app.get('/health', (req, res) => {
//   res.json({ 
//     status: 'ok', 
//     timestamp: new Date().toISOString(),
//     service: 'dyad-backend',
//     version: '1.0.0'
//   });
// });

// // Projects endpoints
// app.get('/api/projects', async (req, res) => {
//   try {
//     console.log('üìÇ Fetching all projects...');
//     const allProjects = await db.select().from(projects);
//     console.log(`üìä Found ${allProjects.length} projects`);
//     res.json(allProjects);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching projects:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/projects', async (req, res) => {
//   try {
//     console.log('üÜï Creating new project:', req.body);
    
//     const projectData = {
//       ...req.body,
//       id: crypto.randomUUID(),
//       createdAt: new Date(),
//       updatedAt: new Date(),
//     };
    
//     const [newProject] = await db.insert(projects).values(projectData).returning();
    
//     console.log('‚úÖ Project created successfully:', newProject.id);
//     res.json(newProject);
//   } catch (error: any) {
//     console.error('‚ùå Error creating project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.get('/api/projects/:id', async (req, res) => {
//   try {
//     const { id } = req.params;
//     console.log('üîç Fetching project:', id);
    
//     const project = await db.query.projects.findFirst({
//       where: eq(projects.id, id),
//     });
    
//     if (!project) {
//       return res.status(404).json({ error: 'Project not found' });
//     }
    
//     res.json(project);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.delete('/api/projects/:id', async (req, res) => {
//   try {
//     const { id } = req.params;
//     console.log('üóëÔ∏è Deleting project:', id);
    
//     // Delete associated files first
//     await db.delete(files).where(eq(files.projectId, id));
    
//     // Then delete the project
//     await db.delete(projects).where(eq(projects.id, id));
    
//     console.log('‚úÖ Project deleted successfully');
//     res.json({ success: true });
//   } catch (error: any) {
//     console.error('‚ùå Error deleting project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Files endpoints
// app.get('/api/files', async (req, res) => {
//   try {
//     const { projectId } = req.query as { projectId: string };
    
//     if (!projectId) {
//       return res.status(400).json({ error: 'Project ID is required' });
//     }
    
//     console.log('üìÅ Fetching files for project:', projectId);
    
//     const projectFiles = await db.query.files.findMany({
//       where: eq(files.projectId, projectId),
//     });
    
//     console.log(`üìä Found ${projectFiles.length} files`);
//     res.json(projectFiles);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching files:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/files', async (req, res) => {
//   try {
//     const { projectId, path: filePath, content } = req.body;
    
//     if (!projectId || !filePath) {
//       return res.status(400).json({ error: 'Project ID and file path are required' });
//     }
    
//     console.log('üíæ Saving file:', filePath, 'in project:', projectId);
    
//     const fileData = {
//       id: crypto.randomUUID(),
//       projectId,
//       path: filePath,
//       content: content || '',
//       type: 'file' as const,
//       createdAt: new Date(),
//       updatedAt: new Date(),
//     };
    
//     // Check if file already exists
//     const existingFile = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, filePath)
//       ),
//     });
    
//     let savedFile;
//     if (existingFile) {
//       // Update existing file
//       [savedFile] = await db.update(files)
//         .set({
//           content: fileData.content,
//           updatedAt: new Date(),
//         })
//         .where(and(
//           eq(files.projectId, projectId),
//           eq(files.path, filePath)
//         ))
//         .returning();
//     } else {
//       // Create new file
//       [savedFile] = await db.insert(files).values(fileData).returning();
//     }
    
//     console.log('‚úÖ File saved successfully');
//     res.json(savedFile);
//   } catch (error: any) {
//     console.error('‚ùå Error saving file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Fixed route for reading files - using query parameters instead of path parameters
// app.get('/api/files/:projectId', async (req, res) => {
//   try {
//     const { projectId } = req.params;
//     const { filePath } = req.query as { filePath: string };
    
//     if (!filePath) {
//       return res.status(400).json({ error: 'File path is required as query parameter' });
//     }

//     console.log('üìÑ Reading file:', filePath, 'from project:', projectId);
    
//     const file = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, decodeURIComponent(filePath))
//       ),
//     });
    
//     if (!file) {
//       return res.status(404).json({ error: 'File not found' });
//     }
    
//     res.json(file);
//   } catch (error: any) {
//     console.error('‚ùå Error reading file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // AI endpoints (mock for now - you can integrate with actual Dyad AI later)
// app.post('/api/ai/generate', async (req, res) => {
//   try {
//     const { prompt, context } = req.body;
//     console.log('ü§ñ AI generate request:', prompt);
    
//     // Mock AI response - replace with actual Dyad AI integration
//     const mockResponse = {
//       content: `// Generated code based on: "${prompt}"\n\nfunction generatedFunction() {\n  console.log('Hello from Dyad AI!');\n  // TODO: Implement actual functionality\n  return {\n    message: 'Code generated successfully',\n    timestamp: new Date().toISOString()\n  };\n}`,
//       files: [
//         {
//           path: 'generated-code.ts',
//           content: `// Auto-generated by Dyad AI\n// Prompt: ${prompt}\n\nexport function generatedCode() {\n  return 'Hello from Dyad!';\n}`
//         }
//       ]
//     };
    
//     // Simulate AI processing delay
//     await new Promise(resolve => setTimeout(resolve, 1000));
    
//     res.json(mockResponse);
//   } catch (error: any) {
//     console.error('‚ùå Error in AI generation:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/ai/chat', async (req, res) => {
//   try {
//     const { messages, projectId } = req.body;
//     console.log('üí¨ AI chat request for project:', projectId);
    
//     // Mock streaming response - replace with actual Dyad AI integration
//     res.setHeader('Content-Type', 'text/plain; charset=utf-8');
//     res.setHeader('Transfer-Encoding', 'chunked');
    
//     const mockResponses = [
//       'Hello! I\'m Dyad AI. ',
//       'I can help you with your project development. ',
//       'What would you like me to help you with today? ',
//       'I can generate code, explain concepts, or assist with debugging. ',
//       'Just let me know what you need!'
//     ];
    
//     for (const chunk of mockResponses) {
//       res.write(chunk);
//       await new Promise(resolve => setTimeout(resolve, 200));
//     }
    
//     res.end();
//   } catch (error: any) {
//     console.error('‚ùå Error in AI chat:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Dev server management endpoints (mock for now)
// app.post('/api/dev-server/start', async (req, res) => {
//   try {
//     const { projectId, port = 3000 } = req.body;
//     console.log('üöÄ Starting dev server for project:', projectId, 'on port:', port);
    
//     // Mock response - integrate with actual Dyad dev server management
//     res.json({
//       url: `http://localhost:${port}`,
//       port,
//       pid: Math.floor(Math.random() * 10000),
//       status: 'running'
//     });
//   } catch (error: any) {
//     console.error('‚ùå Error starting dev server:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/dev-server/stop', async (req, res) => {
//   try {
//     const { projectId } = req.body;
//     console.log('üõë Stopping dev server for project:', projectId);
    
//     // Mock response - integrate with actual Dyad dev server management
//     res.json({ success: true, status: 'stopped' });
//   } catch (error: any) {
//     console.error('‚ùå Error stopping dev server:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // WebSocket setup for real-time updates
// const wss = new WebSocketServer({ server });

// wss.on('connection', (ws, request) => {
//   const clientIP = request.socket.remoteAddress;
//   console.log('üîå New WebSocket connection from:', clientIP);
  
//   // Send welcome message
//   ws.send(JSON.stringify({
//     type: 'connection',
//     message: 'Connected to Dyad backend',
//     timestamp: new Date().toISOString()
//   }));
  
//   ws.on('message', (message) => {
//     try {
//       const data = JSON.parse(message.toString());
//       console.log('üì® Received WebSocket message:', data);
      
//       // Echo back for testing
//       ws.send(JSON.stringify({
//         type: 'echo',
//         originalMessage: data,
//         timestamp: new Date().toISOString()
//       }));
//     } catch (error) {
//       console.error('‚ùå WebSocket message error:', error);
//     }
//   });
  
//   ws.on('close', () => {
//     console.log('üîå WebSocket connection closed');
//   });
  
//   ws.on('error', (error) => {
//     console.error('‚ùå WebSocket error:', error);
//   });
// });

// // Error handling middleware
// app.use((error: any, req: any, res: any, next: any) => {
//   console.error('üö® Server error:', error);
//   res.status(500).json({ 
//     error: 'Internal server error',
//     message: error.message 
//   });
// });

// // Start the server
// server.listen(PORT, '0.0.0.0', async () => {
//   console.log('üéâ Dyad Backend Server Started!');
//   console.log(`üåê HTTP API: http://localhost:${PORT}`);
//   console.log(`üîå WebSocket: ws://localhost:${PORT}`);
  
//   // Initialize the database
//   try {
//     console.log('üîß Initializing database...');
//     await initializeDatabase();
//     console.log('‚úÖ Database initialized successfully!');
//   } catch (error) {
//     console.error('‚ùå Database initialization failed:', error);
//     process.exit(1);
//   }
  
//   console.log('üí° Ready to accept connections from bolt.diy');
//   console.log('üì° CORS enabled for: http://localhost:5173, http://localhost:3000');
// });

// // Graceful shutdown
// process.on('SIGTERM', () => {
//   console.log('üõë Shutting down Dyad backend server...');
//   server.close(() => {
//     console.log('‚úÖ Server closed gracefully');
//     process.exit(0);
//   });
// });
// // Serve custom UI from public
// const uiPath = path.join(__dirname, "../../public");
// app.use(express.static(uiPath));

// // React Router fallback
// app.get("*", (_req, res) => {
//   res.sendFile(path.join(uiPath, "index.html"));
// });
// import express from 'express';
// import cors from 'cors';
// import { WebSocketServer } from 'ws';
// import { createServer } from 'http';
// import { db, initializeDatabase } from '../db';
// import { projects, files } from '../db/schema';
// import { eq, and } from 'drizzle-orm';
// import path from "path";
// import crypto from 'crypto';

// const app = express();
// const server = createServer(app);
// const PORT = 9999;

// app.use(cors({
//   origin: ['http://localhost:5173', 'http://localhost:3000'], // bolt.diy dev servers
//   credentials: true,
//   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
//   allowedHeaders: ['Content-Type', 'Authorization']
// }));

// app.use(express.json({ limit: '50mb' }));
// app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// // ============= DYAD UI ROUTE - ADD THIS =============
// app.get('/dyad', (req, res) => {
//   res.send(`
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Dyad AI Dashboard</title>
//     <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
//     <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
//     <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
//     <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
//     <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
//     <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
//     <style>
//         * { margin: 0; padding: 0; box-sizing: border-box; }
//         body { 
//             font-family: 'Segoe UI', system-ui, sans-serif; 
//             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
//             min-height: 100vh;
//             color: #333;
//         }
//         .dashboard { 
//             display: flex; 
//             height: 100vh; 
//             overflow: hidden;
//         }
//         .sidebar { 
//             width: 300px; 
//             background: rgba(255,255,255,0.95); 
//             backdrop-filter: blur(10px);
//             border-right: 1px solid rgba(255,255,255,0.2);
//             display: flex; 
//             flex-direction: column;
//             box-shadow: 2px 0 20px rgba(0,0,0,0.1);
//         }
//         .main-content { 
//             flex: 1; 
//             display: flex; 
//             flex-direction: column;
//             overflow: hidden;
//         }
//         .header { 
//             background: rgba(255,255,255,0.95); 
//             backdrop-filter: blur(10px);
//             padding: 1rem 2rem; 
//             border-bottom: 1px solid rgba(255,255,255,0.2);
//             display: flex; 
//             align-items: center; 
//             justify-content: space-between;
//             box-shadow: 0 2px 20px rgba(0,0,0,0.1);
//         }
//         .logo { 
//             font-size: 1.5rem; 
//             font-weight: bold; 
//             color: #667eea;
//             display: flex;
//             align-items: center;
//             gap: 0.5rem;
//         }
//         .content { 
//             flex: 1; 
//             padding: 2rem; 
//             overflow-y: auto;
//             background: rgba(255,255,255,0.1);
//         }
//         .project-grid { 
//             display: grid; 
//             grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
//             gap: 1.5rem;
//         }
//         .project-card { 
//             background: rgba(255,255,255,0.95); 
//             backdrop-filter: blur(10px);
//             border-radius: 12px; 
//             padding: 1.5rem; 
//             box-shadow: 0 8px 32px rgba(0,0,0,0.1);
//             border: 1px solid rgba(255,255,255,0.2);
//             transition: all 0.3s ease;
//             cursor: pointer;
//         }
//         .project-card:hover { 
//             transform: translateY(-5px); 
//             box-shadow: 0 12px 40px rgba(0,0,0,0.15);
//         }
//         .btn { 
//             padding: 0.75rem 1.5rem; 
//             border: none; 
//             border-radius: 8px; 
//             cursor: pointer; 
//             font-weight: 500; 
//             transition: all 0.3s ease;
//             display: inline-flex;
//             align-items: center;
//             gap: 0.5rem;
//         }
//         .btn-primary { 
//             background: linear-gradient(135deg, #667eea, #764ba2); 
//             color: white; 
//         }
//         .btn-primary:hover { 
//             transform: translateY(-2px); 
//             box-shadow: 0 8px 25px rgba(102,126,234,0.3);
//         }
//         .btn-secondary { 
//             background: rgba(255,255,255,0.2); 
//             color: #333; 
//             border: 1px solid rgba(255,255,255,0.3);
//         }
//         .btn-danger { 
//             background: linear-gradient(135deg, #ff6b6b, #ee5a52); 
//             color: white; 
//         }
//         .input { 
//             width: 100%; 
//             padding: 0.75rem; 
//             border: 1px solid rgba(255,255,255,0.3); 
//             border-radius: 8px; 
//             background: rgba(255,255,255,0.9);
//             margin-bottom: 1rem;
//         }
//         .modal { 
//             position: fixed; 
//             top: 0; 
//             left: 0; 
//             width: 100%; 
//             height: 100%; 
//             background: rgba(0,0,0,0.5); 
//             backdrop-filter: blur(5px);
//             display: flex; 
//             align-items: center; 
//             justify-content: center; 
//             z-index: 1000;
//         }
//         .modal-content { 
//             background: rgba(255,255,255,0.95); 
//             backdrop-filter: blur(10px);
//             border-radius: 12px; 
//             padding: 2rem; 
//             max-width: 500px; 
//             width: 90%;
//             box-shadow: 0 20px 60px rgba(0,0,0,0.3);
//         }
//         .file-tree { 
//             background: rgba(255,255,255,0.9); 
//             border-radius: 8px; 
//             padding: 1rem; 
//             margin-bottom: 1rem;
//             max-height: 200px;
//             overflow-y: auto;
//         }
//         .file-item { 
//             padding: 0.5rem; 
//             cursor: pointer; 
//             border-radius: 4px; 
//             transition: background 0.2s;
//         }
//         .file-item:hover { 
//             background: rgba(102,126,234,0.1); 
//         }
//         .editor-container { 
//             height: 400px; 
//             border: 1px solid rgba(255,255,255,0.3); 
//             border-radius: 8px; 
//             overflow: hidden;
//         }
//         .chat-container { 
//             height: 300px; 
//             background: rgba(255,255,255,0.9); 
//             border-radius: 8px; 
//             padding: 1rem; 
//             overflow-y: auto; 
//             margin-bottom: 1rem;
//         }
//         .chat-input { 
//             display: flex; 
//             gap: 0.5rem;
//         }
//         .status-indicator { 
//             width: 10px; 
//             height: 10px; 
//             border-radius: 50%; 
//             display: inline-block; 
//             margin-right: 0.5rem;
//         }
//         .status-connected { background: #4CAF50; }
//         .status-disconnected { background: #f44336; }
//         .loading { 
//             display: inline-block; 
//             width: 20px; 
//             height: 20px; 
//             border: 3px solid rgba(255,255,255,0.3); 
//             border-radius: 50%; 
//             border-top-color: #667eea; 
//             animation: spin 1s ease-in-out infinite;
//         }
//         @keyframes spin { 
//             to { transform: rotate(360deg); } 
//         }
//         .tab-container { 
//             display: flex; 
//             border-bottom: 1px solid rgba(255,255,255,0.3);
//         }
//         .tab { 
//             padding: 1rem 2rem; 
//             cursor: pointer; 
//             border-bottom: 2px solid transparent; 
//             transition: all 0.3s ease;
//         }
//         .tab.active { 
//             border-bottom-color: #667eea; 
//             background: rgba(102,126,234,0.1);
//         }
//         .tab-content { 
//             padding: 2rem 0;
//         }
//         .hidden { 
//             display: none !important; 
//         }
//     </style>
// </head>
// <body>
//     <div id="root"></div>

//     <script type="text/babel">
//         const { useState, useEffect, useRef } = React;

//         // Main Dashboard Component
//         function DyadDashboard() {
//             const [activeTab, setActiveTab] = useState('projects');
//             const [projects, setProjects] = useState([]);
//             const [selectedProject, setSelectedProject] = useState(null);
//             const [files, setFiles] = useState([]);
//             const [selectedFile, setSelectedFile] = useState(null);
//             const [showCreateModal, setShowCreateModal] = useState(false);
//             const [loading, setLoading] = useState(false);
//             const [wsConnected, setWsConnected] = useState(false);
//             const [chatMessages, setChatMessages] = useState([]);
//             const [fileContent, setFileContent] = useState('');

//             // WebSocket connection
//             useEffect(() => {
//                 const ws = new WebSocket('ws://localhost:9999');
                
//                 ws.onopen = () => {
//                     setWsConnected(true);
//                     console.log('Connected to Dyad WebSocket');
//                 };
                
//                 ws.onclose = () => {
//                     setWsConnected(false);
//                     console.log('Disconnected from Dyad WebSocket');
//                 };
                
//                 ws.onmessage = (event) => {
//                     const data = JSON.parse(event.data);
//                     console.log('WebSocket message:', data);
//                 };

//                 return () => ws.close();
//             }, []);

//             // Load projects on mount
//             useEffect(() => {
//                 loadProjects();
//             }, []);

//             const loadProjects = async () => {
//                 try {
//                     setLoading(true);
//                     const response = await axios.get('http://localhost:9999/api/projects');
//                     setProjects(response.data);
//                 } catch (error) {
//                     console.error('Error loading projects:', error);
//                 } finally {
//                     setLoading(false);
//                 }
//             };

//             const createProject = async (projectData) => {
//                 try {
//                     setLoading(true);
//                     const response = await axios.post('http://localhost:9999/api/projects', projectData);
//                     await loadProjects();
//                     setShowCreateModal(false);
//                 } catch (error) {
//                     console.error('Error creating project:', error);
//                 } finally {
//                     setLoading(false);
//                 }
//             };

//             const deleteProject = async (projectId) => {
//                 if (confirm('Are you sure you want to delete this project?')) {
//                     try {
//                         await axios.delete(\`http://localhost:9999/api/projects/\${projectId}\`);
//                         await loadProjects();
//                         if (selectedProject?.id === projectId) {
//                             setSelectedProject(null);
//                             setFiles([]);
//                         }
//                     } catch (error) {
//                         console.error('Error deleting project:', error);
//                     }
//                 }
//             };

//             const loadFiles = async (projectId) => {
//                 try {
//                     const response = await axios.get(\`http://localhost:9999/api/files?projectId=\${projectId}\`);
//                     setFiles(response.data);
//                 } catch (error) {
//                     console.error('Error loading files:', error);
//                 }
//             };

//             const selectProject = async (project) => {
//                 setSelectedProject(project);
//                 await loadFiles(project.id);
//                 setActiveTab('editor');
//             };

//             const saveFile = async (projectId, filePath, content) => {
//                 try {
//                     await axios.post('http://localhost:9999/api/files', {
//                         projectId,
//                         path: filePath,
//                         content
//                     });
//                     console.log('File saved successfully');
//                 } catch (error) {
//                     console.error('Error saving file:', error);
//                 }
//             };

//             const sendChatMessage = async (message) => {
//                 try {
//                     setChatMessages(prev => [...prev, { role: 'user', content: message }]);
                    
//                     const response = await axios.post('http://localhost:9999/api/ai/chat', {
//                         messages: [...chatMessages, { role: 'user', content: message }],
//                         projectId: selectedProject?.id
//                     });
                    
//                     setChatMessages(prev => [...prev, { role: 'assistant', content: 'AI response received!' }]);
//                 } catch (error) {
//                     console.error('Error sending chat message:', error);
//                 }
//             };

//             return (
//                 <div className="dashboard">
//                     <Sidebar 
//                         wsConnected={wsConnected}
//                         activeTab={activeTab}
//                         setActiveTab={setActiveTab}
//                         selectedProject={selectedProject}
//                         projects={projects}
//                         selectProject={selectProject}
//                     />
//                     <div className="main-content">
//                         <Header 
//                             wsConnected={wsConnected}
//                             selectedProject={selectedProject}
//                             onCreateProject={() => setShowCreateModal(true)}
//                         />
//                         <div className="content">
//                             {activeTab === 'projects' && (
//                                 <ProjectsTab 
//                                     projects={projects}
//                                     loading={loading}
//                                     onSelectProject={selectProject}
//                                     onDeleteProject={deleteProject}
//                                 />
//                             )}
//                             {activeTab === 'editor' && (
//                                 <EditorTab 
//                                     selectedProject={selectedProject}
//                                     files={files}
//                                     fileContent={fileContent}
//                                     setFileContent={setFileContent}
//                                     onSaveFile={saveFile}
//                                 />
//                             )}
//                             {activeTab === 'ai-chat' && (
//                                 <AIChatTab 
//                                     messages={chatMessages}
//                                     onSendMessage={sendChatMessage}
//                                 />
//                             )}
//                         </div>
//                     </div>
//                     {showCreateModal && (
//                         <CreateProjectModal 
//                             onClose={() => setShowCreateModal(false)}
//                             onCreate={createProject}
//                         />
//                     )}
//                 </div>
//             );
//         }

//         // Sidebar Component
//         function Sidebar({ wsConnected, activeTab, setActiveTab, selectedProject, projects, selectProject }) {
//             const tabs = [
//                 { id: 'projects', icon: 'fas fa-folder', label: 'Projects' },
//                 { id: 'editor', icon: 'fas fa-code', label: 'Editor' },
//                 { id: 'ai-chat', icon: 'fas fa-robot', label: 'AI Chat' }
//             ];

//             return (
//                 <div className="sidebar">
//                     <div style={{ padding: '1.5rem' }}>
//                         <h2 className="logo">
//                             <i className="fas fa-cube"></i>
//                             Dyad AI
//                         </h2>
//                         <div style={{ marginTop: '0.5rem', fontSize: '0.8rem', color: '#666' }}>
//                             <span className={\`status-indicator \${wsConnected ? 'status-connected' : 'status-disconnected'}\`}></span>
//                             {wsConnected ? 'Connected' : 'Disconnected'}
//                         </div>
//                     </div>
                    
//                     <div className="tab-container" style={{ flexDirection: 'column', borderBottom: 'none' }}>
//                         {tabs.map(tab => (
//                             <div 
//                                 key={tab.id}
//                                 className={\`tab \${activeTab === tab.id ? 'active' : ''}\`}
//                                 onClick={() => setActiveTab(tab.id)}
//                                 style={{ borderBottom: 'none', borderLeft: activeTab === tab.id ? '3px solid #667eea' : 'none' }}
//                             >
//                                 <i className={tab.icon}></i> {tab.label}
//                             </div>
//                         ))}
//                     </div>

//                     <div style={{ padding: '1rem', flex: 1 }}>
//                         {selectedProject && (
//                             <div>
//                                 <h4>Current Project</h4>
//                                 <div className="project-card" style={{ marginTop: '0.5rem', padding: '1rem' }}>
//                                     <h5>{selectedProject.name}</h5>
//                                     <p style={{ fontSize: '0.8rem', color: '#666', marginTop: '0.5rem' }}>
//                                         {selectedProject.framework}
//                                     </p>
//                                 </div>
//                             </div>
//                         )}

//                         {projects.length > 0 && (
//                             <div style={{ marginTop: '1rem' }}>
//                                 <h4>Quick Access</h4>
//                                 {projects.slice(0, 3).map(project => (
//                                     <div 
//                                         key={project.id}
//                                         className="file-item"
//                                         onClick={() => selectProject(project)}
//                                     >
//                                         <i className="fas fa-folder-open"></i> {project.name}
//                                     </div>
//                                 ))}
//                             </div>
//                         )}
//                     </div>
//                 </div>
//             );
//         }

//         // Header Component
//         function Header({ wsConnected, selectedProject, onCreateProject }) {
//             return (
//                 <div className="header">
//                     <div>
//                         <h1 style={{ margin: 0 }}>Dashboard</h1>
//                         {selectedProject && (
//                             <p style={{ margin: 0, color: '#666' }}>Editing: {selectedProject.name}</p>
//                         )}
//                     </div>
//                     <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
//                         <button className="btn btn-primary" onClick={onCreateProject}>
//                             <i className="fas fa-plus"></i> New Project
//                         </button>
//                     </div>
//                 </div>
//             );
//         }

//         // Projects Tab
//         function ProjectsTab({ projects, loading, onSelectProject, onDeleteProject }) {
//             if (loading) {
//                 return <div style={{ textAlign: 'center', padding: '2rem' }}>
//                     <div className="loading"></div>
//                     <p>Loading projects...</p>
//                 </div>;
//             }

//             return (
//                 <div>
//                     <h2 style={{ marginBottom: '1.5rem', color: 'white' }}>Your Projects</h2>
//                     <div className="project-grid">
//                         {projects.map(project => (
//                             <div key={project.id} className="project-card">
//                                 <h3>{project.name}</h3>
//                                 <p style={{ color: '#666', margin: '0.5rem 0' }}>{project.description}</p>
//                                 <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem' }}>
//                                     <span style={{ 
//                                         background: '#667eea', 
//                                         color: 'white', 
//                                         padding: '0.25rem 0.5rem', 
//                                         borderRadius: '4px', 
//                                         fontSize: '0.8rem' 
//                                     }}>
//                                         {project.framework}
//                                     </span>
//                                     <div style={{ display: 'flex', gap: '0.5rem' }}>
//                                         <button 
//                                             className="btn btn-secondary"
//                                             onClick={() => onSelectProject(project)}
//                                         >
//                                             <i className="fas fa-edit"></i> Open
//                                         </button>
//                                         <button 
//                                             className="btn btn-danger"
//                                             onClick={() => onDeleteProject(project.id)}
//                                         >
//                                             <i className="fas fa-trash"></i>
//                                         </button>
//                                     </div>
//                                 </div>
//                             </div>
//                         ))}
//                     </div>
//                 </div>
//             );
//         }

//         // Editor Tab
//         function EditorTab({ selectedProject, files, fileContent, setFileContent, onSaveFile }) {
//             const [selectedFile, setSelectedFile] = useState(null);
//             const [newFileName, setNewFileName] = useState('');

//             if (!selectedProject) {
//                 return (
//                     <div style={{ textAlign: 'center', padding: '2rem', color: 'white' }}>
//                         <i className="fas fa-folder-open" style={{ fontSize: '3rem', marginBottom: '1rem' }}></i>
//                         <h3>No Project Selected</h3>
//                         <p>Please select a project from the Projects tab to start editing.</p>
//                     </div>
//                 );
//             }

//             const createFile = async () => {
//                 if (newFileName.trim()) {
//                     await onSaveFile(selectedProject.id, newFileName, '// New file\\n');
//                     setNewFileName('');
//                     window.location.reload(); // Refresh to show new file
//                 }
//             };

//             const selectFile = (file) => {
//                 setSelectedFile(file);
//                 setFileContent(file.content || '');
//             };

//             const saveCurrentFile = async () => {
//                 if (selectedFile) {
//                     await onSaveFile(selectedProject.id, selectedFile.path, fileContent);
//                     alert('File saved successfully!');
//                 }
//             };

//             return (
//                 <div>
//                     <div style={{ display: 'flex', gap: '2rem', height: '100%' }}>
//                         <div style={{ width: '300px' }}>
//                             <h3 style={{ color: 'white', marginBottom: '1rem' }}>Files</h3>
//                             <div className="file-tree">
//                                 <div style={{ marginBottom: '1rem' }}>
//                                     <input 
//                                         type="text" 
//                                         placeholder="New file name..." 
//                                         value={newFileName}
//                                         onChange={(e) => setNewFileName(e.target.value)}
//                                         className="input"
//                                         style={{ marginBottom: '0.5rem' }}
//                                     />
//                                     <button className="btn btn-primary" onClick={createFile} style={{ width: '100%' }}>
//                                         <i className="fas fa-plus"></i> Create File
//                                     </button>
//                                 </div>
//                                 {files.map(file => (
//                                     <div 
//                                         key={file.id} 
//                                         className={\`file-item \${selectedFile?.id === file.id ? 'active' : ''}\`}
//                                         onClick={() => selectFile(file)}
//                                         style={{ 
//                                             background: selectedFile?.id === file.id ? 'rgba(102,126,234,0.2)' : 'transparent'
//                                         }}
//                                     >
//                                         <i className="fas fa-file-code"></i> {file.path}
//                                     </div>
//                                 ))}
//                             </div>
//                         </div>
//                         <div style={{ flex: 1 }}>
//                             {selectedFile ? (
//                                 <div>
//                                     <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
//                                         <h3 style={{ color: 'white' }}>Editing: {selectedFile.path}</h3>
//                                         <button className="btn btn-primary" onClick={saveCurrentFile}>
//                                             <i className="fas fa-save"></i> Save File
//                                         </button>
//                                     </div>
//                                     <textarea 
//                                         value={fileContent}
//                                         onChange={(e) => setFileContent(e.target.value)}
//                                         style={{ 
//                                             width: '100%', 
//                                             height: '500px', 
//                                             fontFamily: 'monospace',
//                                             background: 'rgba(255,255,255,0.95)',
//                                             border: '1px solid rgba(255,255,255,0.3)',
//                                             borderRadius: '8px',
//                                             padding: '1rem'
//                                         }}
//                                         placeholder="Enter your code here..."
//                                     />
//                                 </div>
//                             ) : (
//                                 <div style={{ textAlign: 'center', padding: '2rem', color: 'white' }}>
//                                     <i className="fas fa-file-code" style={{ fontSize: '3rem', marginBottom: '1rem' }}></i>
//                                     <h3>No File Selected</h3>
//                                     <p>Select a file from the file tree to start editing.</p>
//                                 </div>
//                             )}
//                         </div>
//                     </div>
//                 </div>
//             );
//         }

//         // AI Chat Tab
//         function AIChatTab({ messages, onSendMessage }) {
//             const [inputValue, setInputValue] = useState('');

//             const sendMessage = () => {
//                 if (inputValue.trim()) {
//                     onSendMessage(inputValue);
//                     setInputValue('');
//                 }
//             };

//             const handleKeyPress = (e) => {
//                 if (e.key === 'Enter' && !e.shiftKey) {
//                     e.preventDefault();
//                     sendMessage();
//                 }
//             };

//             return (
//                 <div>
//                     <h2 style={{ marginBottom: '1.5rem', color: 'white' }}>AI Assistant</h2>
//                     <div className="chat-container">
//                         {messages.length === 0 ? (
//                             <div style={{ textAlign: 'center', color: '#666', padding: '2rem' }}>
//                                 <i className="fas fa-robot" style={{ fontSize: '2rem', marginBottom: '1rem' }}></i>
//                                 <p>Start a conversation with the AI assistant!</p>
//                             </div>
//                         ) : (
//                             messages.map((msg, idx) => (
//                                 <div key={idx} style={{ 
//                                     marginBottom: '1rem', 
//                                     padding: '0.5rem',
//                                     background: msg.role === 'user' ? '#667eea' : '#f0f0f0',
//                                     color: msg.role === 'user' ? 'white' : '#333',
//                                     borderRadius: '8px',
//                                     marginLeft: msg.role === 'user' ? '2rem' : '0',
//                                     marginRight: msg.role === 'assistant' ? '2rem' : '0'
//                                 }}>
//                                     <strong>{msg.role === 'user' ? 'You' : 'AI'}:</strong> {msg.content}
//                                 </div>
//                             ))
//                         )}
//                     </div>
//                     <div className="chat-input">
//                         <textarea 
//                             value={inputValue}
//                             onChange={(e) => setInputValue(e.target.value)}
//                             onKeyPress={handleKeyPress}
//                             placeholder="Ask the AI assistant anything..."
//                             style={{ 
//                                 flex: 1, 
//                                 padding: '1rem', 
//                                 border: '1px solid rgba(255,255,255,0.3)', 
//                                 borderRadius: '8px',
//                                 background: 'rgba(255,255,255,0.95)',
//                                 resize: 'none',
//                                 minHeight: '60px'
//                             }}
//                         />
//                         <button className="btn btn-primary" onClick={sendMessage}>
//                             <i className="fas fa-paper-plane"></i> Send
//                         </button>
//                     </div>
//                 </div>
//             );
//         }

//         // Create Project Modal
//         function CreateProjectModal({ onClose, onCreate }) {
//             const [name, setName] = useState('');
//             const [description, setDescription] = useState('');
//             const [framework, setFramework] = useState('react');

//             const handleSubmit = (e) => {
//                 e.preventDefault();
//                 if (name.trim()) {
//                     onCreate({ name, description, framework });
//                 }
//             };

//             return (
//                 <div className="modal">
//                     <div className="modal-content">
//                         <h2>Create New Project</h2>
//                         <form onSubmit={handleSubmit}>
//                             <input 
//                                 type="text" 
//                                 placeholder="Project Name" 
//                                 value={name}
//                                 onChange={(e) => setName(e.target.value)}
//                                 className="input"
//                                 required
//                             />
//                             <textarea 
//                                 placeholder="Project Description" 
//                                 value={description}
//                                 onChange={(e) => setDescription(e.target.value)}
//                                 className="input"
//                                 style={{ minHeight: '80px', resize: 'vertical' }}
//                             />
//                             <select 
//                                 value={framework}
//                                 onChange={(e) => setFramework(e.target.value)}
//                                 className="input"
//                             >
//                                 <option value="react">React</option>
//                                 <option value="vue">Vue.js</option>
//                                 <option value="angular">Angular</option>
//                                 <option value="svelte">Svelte</option>
//                                 <option value="vanilla">Vanilla JS</option>
//                                 <option value="node">Node.js</option>
//                                 <option value="python">Python</option>
//                                 <option value="nextjs">Next.js</option>
//                             </select>
//                             <div style={{ display: 'flex', gap: '1rem', marginTop: '1.5rem' }}>
//                                 <button type="button" className="btn btn-secondary" onClick={onClose}>
//                                     Cancel
//                                 </button>
//                                 <button type="submit" className="btn btn-primary">
//                                     <i className="fas fa-plus"></i> Create Project
//                                 </button>
//                             </div>
//                         </form>
//                     </div>
//                 </div>
//             );
//         }

//         // Render the app
//         ReactDOM.render(<DyadDashboard />, document.getElementById('root'));
//     </script>
// </body>
// </html>
//   `);
// });

// // Health check endpoint
// app.get('/health', (req, res) => {
//   res.json({ 
//     status: 'ok', 
//     timestamp: new Date().toISOString(),
//     service: 'dyad-backend',
//     version: '1.0.0'
//   });
// });

// // Projects endpoints
// app.get('/api/projects', async (req, res) => {
//   try {
//     console.log('üìÇ Fetching all projects...');
//     const allProjects = await db.select().from(projects);
//     console.log(`üìä Found ${allProjects.length} projects`);
//     res.json(allProjects);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching projects:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/projects', async (req, res) => {
//   try {
//     console.log('üÜï Creating new project:', req.body);
    
//     const projectData = {
//       ...req.body,
//       id: crypto.randomUUID(),
//       createdAt: new Date(),
//       updatedAt: new Date(),
//     };
    
//     const [newProject] = await db.insert(projects).values(projectData).returning();
    
//     console.log('‚úÖ Project created successfully:', newProject.id);
//     res.json(newProject);
//   } catch (error: any) {
//     console.error('‚ùå Error creating project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.get('/api/projects/:id', async (req, res) => {
//   try {
//     const { id } = req.params;
//     console.log('üîç Fetching project:', id);
    
//     const project = await db.query.projects.findFirst({
//       where: eq(projects.id, id),
//     });
    
//     if (!project) {
//       return res.status(404).json({ error: 'Project not found' });
//     }
    
//     res.json(project);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.delete('/api/projects/:id', async (req, res) => {
//   try {
//     const { id } = req.params;
//     console.log('üóëÔ∏è Deleting project:', id);
    
//     // Delete associated files first
//     await db.delete(files).where(eq(files.projectId, id));
    
//     // Then delete the project
//     await db.delete(projects).where(eq(projects.id, id));
    
//     console.log('‚úÖ Project deleted successfully');
//     res.json({ success: true });
//   } catch (error: any) {
//     console.error('‚ùå Error deleting project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Files endpoints
// app.get('/api/files', async (req, res) => {
//   try {
//     const { projectId } = req.query as { projectId: string };
    
//     if (!projectId) {
//       return res.status(400).json({ error: 'Project ID is required' });
//     }
    
//     console.log('üìÅ Fetching files for project:', projectId);
    
//     const projectFiles = await db.query.files.findMany({
//       where: eq(files.projectId, projectId),
//     });
    
//     console.log(`üìä Found ${projectFiles.length} files`);
//     res.json(projectFiles);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching files:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/files', async (req, res) => {
//   try {
//     const { projectId, path: filePath, content } = req.body;
    
//     if (!projectId || !filePath) {
//       return res.status(400).json({ error: 'Project ID and file path are required' });
//     }
    
//     console.log('üíæ Saving file:', filePath, 'in project:', projectId);
    
//     const fileData = {
//       id: crypto.randomUUID(),
//       projectId,
//       path: filePath,
//       content: content || '',
//       type: 'file' as const,
//       createdAt: new Date(),
//       updatedAt: new Date(),
//     };
    
//     // Check if file already exists
//     const existingFile = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, filePath)
//       ),
//     });
    
//     let savedFile;
//     if (existingFile) {
//       // Update existing file
//       [savedFile] = await db.update(files)
//         .set({
//           content: fileData.content,
//           updatedAt: new Date(),
//         })
//         .where(and(
//           eq(files.projectId, projectId),
//           eq(files.path, filePath)
//         ))
//         .returning();
//     } else {
//       // Create new file
//       [savedFile] = await db.insert(files).values(fileData).returning();
//     }
    
//     console.log('‚úÖ File saved successfully');
//     res.json(savedFile);
//   } catch (error: any) {
//     console.error('‚ùå Error saving file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Fixed route for reading files - using query parameters instead of path parameters
// app.get('/api/files/:projectId', async (req, res) => {
//   try {
//     const { projectId } = req.params;
//     const { filePath } = req.query as { filePath: string };
    
//     if (!filePath) {
//       return res.status(400).json({ error: 'File path is required as query parameter' });
//     }

//     console.log('üìÑ Reading file:', filePath, 'from project:', projectId);
    
//     const file = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, decodeURIComponent(filePath))
//       ),
//     });
    
//     if (!file) {
//       return res.status(404).json({ error: 'File not found' });
//     }
    
//     res.json(file);
//   } catch (error: any) {
//     console.error('‚ùå Error reading file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // AI endpoints (mock for now - you can integrate with actual Dyad AI later)
// app.post('/api/ai/generate', async (req, res) => {
//   try {
//     const { prompt, context } = req.body;
//     console.log('ü§ñ AI generate request:', prompt);
    
//     // Mock AI response - replace with actual Dyad AI integration
//     const mockResponse = {
//       content: `// Generated code based on: "${prompt}"\n\nfunction generatedFunction() {\n  console.log('Hello from Dyad AI!');\n  // TODO: Implement actual functionality\n  return {\n    message: 'Code generated successfully',\n    timestamp: new Date().toISOString()\n  };\n}`,
//       files: [
//         {
//           path: 'generated-code.ts',
//           content: `// Auto-generated by Dyad AI\n// Prompt: ${prompt}\n\nexport function generatedCode() {\n  return 'Hello from Dyad!';\n}`
//         }
//       ]
//     };
    
//     // Simulate AI processing delay
//     await new Promise(resolve => setTimeout(resolve, 1000));
    
//     res.json(mockResponse);
//   } catch (error: any) {
//     console.error('‚ùå Error in AI generation:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/ai/chat', async (req, res) => {
//   try {
//     const { messages, projectId } = req.body;
//     console.log('üí¨ AI chat request for project:', projectId);
    
//     // Mock streaming response - replace with actual Dyad AI integration
//     res.setHeader('Content-Type', 'text/plain; charset=utf-8');
//     res.setHeader('Transfer-Encoding', 'chunked');
    
//     const mockResponses = [
//       'Hello! I\'m Dyad AI. ',
//       'I can help you with your project development. ',
//       'What would you like me to help you with today? ',
//       'I can generate code, explain concepts, or assist with debugging. ',
//       'Just let me know what you need!'
//     ];
    
//     for (const chunk of mockResponses) {
//       res.write(chunk);
//       await new Promise(resolve => setTimeout(resolve, 200));
//     }
    
//     res.end();
//   } catch (error: any) {
//     console.error('‚ùå Error in AI chat:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Dev server management endpoints (mock for now)
// app.post('/api/dev-server/start', async (req, res) => {
//   try {
//     const { projectId, port = 3000 } = req.body;
//     console.log('üöÄ Starting dev server for project:', projectId, 'on port:', port);
    
//     // Mock response - integrate with actual Dyad dev server management
//     res.json({
//       url: `http://localhost:${port}`,
//       port,
//       pid: Math.floor(Math.random() * 10000),
//       status: 'running'
//     });
//   } catch (error: any) {
//     console.error('‚ùå Error starting dev server:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// app.post('/api/dev-server/stop', async (req, res) => {
//   try {
//     const { projectId } = req.body;
//     console.log('üõë Stopping dev server for project:', projectId);
    
//     // Mock response - integrate with actual Dyad dev server management
//     res.json({ success: true, status: 'stopped' });
//   } catch (error: any) {
//     console.error('‚ùå Error stopping dev server:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // WebSocket setup for real-time updates
// const wss = new WebSocketServer({ server });

// wss.on('connection', (ws, request) => {
//   const clientIP = request.socket.remoteAddress;
//   console.log('üîå New WebSocket connection from:', clientIP);
  
//   // Send welcome message
//   ws.send(JSON.stringify({
//     type: 'connection',
//     message: 'Connected to Dyad backend',
//     timestamp: new Date().toISOString()
//   }));
  
//   ws.on('message', (message) => {
//     try {
//       const data = JSON.parse(message.toString());
//       console.log('üì® Received WebSocket message:', data);
      
//       // Echo back for testing
//       ws.send(JSON.stringify({
//         type: 'echo',
//         originalMessage: data,
//         timestamp: new Date().toISOString()
//       }));
//     } catch (error) {
//       console.error('‚ùå WebSocket message error:', error);
//     }
//   });
  
//   ws.on('close', () => {
//     console.log('üîå WebSocket connection closed');
//   });
  
//   ws.on('error', (error) => {
//     console.error('‚ùå WebSocket error:', error);
//   });
// });

// // Error handling middleware
// app.use((error: any, req: any, res: any, next: any) => {
//   console.error('üö® Server error:', error);
//   res.status(500).json({ 
//     error: 'Internal server error',
//     message: error.message 
//   });
// });

// // Start the server
// server.listen(PORT, '0.0.0.0', async () => {
//   console.log('üéâ Dyad Backend Server Started!');
//   console.log(`üåê HTTP API: http://localhost:${PORT}`);
//   console.log(`üîå WebSocket: ws://localhost:${PORT}`);
//   console.log(`üé® Dyad UI: http://localhost:${PORT}/dyad`);
  
//   // Initialize the database
//   try {
//     console.log('üîß Initializing database...');
//     await initializeDatabase();
//     console.log('‚úÖ Database initialized successfully!');
//   } catch (error) {
//     console.error('‚ùå Database initialization failed:', error);
//     process.exit(1);
//   }
  
//   console.log('üí° Ready to accept connections from bolt.diy');
//   console.log('üì° CORS enabled for: http://localhost:5173, http://localhost:3000');
// });

// // Graceful shutdown
// process.on('SIGTERM', () => {
//   console.log('üõë Shutting down Dyad backend server...');
//   server.close(() => {
//     console.log('‚úÖ Server closed gracefully');
//     process.exit(0);
//   });
// });
import express from 'express';
import cors from 'cors';
import { WebSocketServer } from 'ws';
import { createServer } from 'http';
import { db, initializeDatabase } from '../db';
// DIRECT IMPORT - Use the exact table names from schema
import { boltProjects, boltFiles } from '../db/schema.js';
import { eq, and } from 'drizzle-orm';
import path from "path";
import crypto from 'crypto';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { projects, files } from '../db/schema'; // ensure this matches your import path

type FileInsert = typeof files.$inferInsert;
type ProjectInsert = typeof projects.$inferInsert;

// // Create aliases after import for cleaner code
// const projects = boltProjects;
// const files = boltFiles;

const app = express();
const server = createServer(app);
const wss = new WebSocketServer({ server });
const PORT = 9999;

// Store WebSocket connections
const wsConnections = new Set();

app.use(cors({
  origin: ['http://localhost:5173', 'http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// WebSocket connection handling
wss.on('connection', (ws, req) => {
  const clientIp = req.socket.remoteAddress;
  console.log(`New WebSocket connection from: ${clientIp}`);
  
  wsConnections.add(ws);
  
  ws.on('message', async (message) => {
    try {
      const data = JSON.parse(message.toString());
      console.log('WebSocket message received:', data.type);
      
      switch (data.type) {
        case 'file_created':
        case 'file_updated':
          await handleFileSync(data);
          break;
        case 'project_created':
          await handleProjectSync(data);
          break;
        case 'bulk_files':
          await handleBulkFileSync(data);
          break;
        default:
          console.log('Unknown message type:', data.type);
      }
    } catch (error) {
      console.error('Error processing WebSocket message:', error);
    }
  });
  
  ws.on('close', () => {
    wsConnections.delete(ws);
    console.log('WebSocket connection closed');
  });
  
  ws.on('error', (error) => {
    console.error('WebSocket error:', error);
    wsConnections.delete(ws);
  });
});

// Broadcast to all connected clients
function broadcast(data: any) {
  const message = JSON.stringify(data);
  wsConnections.forEach((ws: any) => {
    if (ws.readyState === ws.OPEN) {
      ws.send(message);
    }
  });
}

// Handle file synchronization from bolt.diy
async function handleFileSync(data: any) {
  try {
    const { projectId, filePath, content, operation } = data;
    
    console.log(`Syncing file: ${filePath} for project: ${projectId}`);
    
    // Check if project exists, if not create it
    let project = await db.select().from(projects).where(eq(projects.id, projectId)).limit(1);
    
    if (project.length === 0) {
      // Create project if it doesn't exist - only use fields that exist in schema
      const projectData: any = {
        id: projectId,
        name: data.projectName || 'Bolt Project'
      };

      // Only add optional fields if they exist in the schema
      if (data.projectDescription) {
        projectData.description = data.projectDescription;
      }
      if (data.framework) {
        projectData.framework = data.framework;
      }
      if (data.template) {
        projectData.template = data.template;
      }

      await db.insert(projects).values(projectData);
      console.log(`Created project: ${projectId}`);
    }
    
    // Check if file already exists
    const existingFile = await db.select().from(files)
      .where(and(eq(files.projectId, projectId), eq(files.path, filePath)))
      .limit(1);
    
    if (existingFile.length > 0) {
      // Update existing file
      await db.update(files)
        .set({
          content: content
        })
        .where(eq(files.id, existingFile[0].id));
      console.log(`Updated file: ${filePath}`);
    } else {
      // Create new file
      await db.insert(files).values({
  id: crypto.randomUUID(),
  projectId,
  path: filePath,
  content: content ?? '',
  type: 'file'
} as any);

      console.log(`Created file: ${filePath}`);
    }
    
    // Broadcast update to connected clients
    broadcast({
      type: 'file_synced',
      projectId,
      filePath,
      operation
    } as any);
    
  } catch (error) {
    console.error('Error syncing file:', error);
  }
}

// Handle project synchronization from bolt.diy
async function handleProjectSync(data: any) {
  try {
    const { projectId, name, description, framework, template } = data;
    
    console.log(`Syncing project: ${name}`);
    
    // Check if project already exists
    const existingProject = await db.select().from(projects)
      .where(eq(projects.id, projectId))
      .limit(1);
    
    if (existingProject.length === 0) {
      const projectData: any = {
        id: projectId,
        name: name
      };

      // Only add optional fields if they exist in the schema and have values
      if (description) {
        projectData.description = description;
      }
      if (framework) {
        projectData.framework = framework;
      }
      if (template) {
        projectData.template = template;
      }

      await db.insert(projects).values(projectData);
      console.log(`Project synced: ${projectId}`);
    }
    
    broadcast({
      type: 'project_synced',
      projectId,
      name
    });
    
  } catch (error) {
    console.error('Error syncing project:', error);
  }
}

// Handle bulk file synchronization from bolt.diy
async function handleBulkFileSync(data: any) {
  try {
    const { projectId, files: filesList, projectName, framework, template } = data;
    
    console.log(`Bulk syncing ${filesList.length} files for project: ${projectId}`);
    
    // Ensure project exists
    let project = await db.select().from(projects).where(eq(projects.id, projectId)).limit(1);
    
    if (project.length === 0) {
      const projectData: any = {
        id: projectId,
        name: projectName || 'Bolt Project'
      };

      // Only add optional fields if they have values
      if (framework) {
        projectData.framework = framework;
      }
      if (template) {
        projectData.template = template;
      }
      // Add default description
      projectData.description = 'Project created from bolt.diy';

      await db.insert(projects).values(projectData);
      console.log(`Created project during bulk sync: ${projectId}`);
    }
    
    // Process each file
    for (const file of filesList) {
      const { path: filePath, content } = file;
      
      // Check if file exists
      const existingFile = await db.select().from(files)
        .where(and(eq(files.projectId, projectId), eq(files.path, filePath)))
        .limit(1);
      
      if (existingFile.length > 0) {
        // Update existing file
        await db.update(files)
          .set({
            content: content
          })
          .where(eq(files.id, existingFile[0].id));
      } else {
        // Create new file
        await db.insert(files).values({
    id: crypto.randomUUID(),
    projectId: projectId,
    path: filePath,
    content: content,
    type: 'file'
  } as any);
      }
    }
    
    console.log(`Bulk sync completed for project: ${projectId}`);
    
    broadcast({
      type: 'bulk_sync_completed',
      projectId,
      filesCount: filesList.length
    });
    
  } catch (error) {
    console.error('Error in bulk file sync:', error);
  }
}

// ============= API ROUTES =============

// Get all projects
app.get('/api/projects', async (req, res) => {
  try {
    console.log('Fetching all projects...');
    const allProjects = await db.select().from(projects).orderBy(projects.updatedAt);
    console.log(`Found ${allProjects.length} projects`);
    res.json(allProjects);
  } catch (error) {
    console.error('Error fetching projects:', error);
    res.status(500).json({ error: 'Failed to fetch projects' });
  }
});

// Create a new project
app.post('/api/projects', async (req, res) => {
  try {
    const { name, description, framework, template } = req.body;
    console.log('Creating new project:', { name, description, framework, template });
    
    const projectId = crypto.randomUUID();
    
    const projectData: any = {
      id: projectId,
      name
    };

    // Only add optional fields if they have values
    if (description) {
      projectData.description = description;
    }
    if (framework) {
      projectData.framework = framework;
    }
    if (template) {
      projectData.template = template;
    }
    
    await db.insert(projects).values(projectData);
    
    console.log(`Project created successfully: ${projectId}`);
    
    broadcast({
      type: 'project_created',
      projectId,
      name
    });
    
    res.json({ id: projectId, name, description, framework, template });
  } catch (error) {
    console.error('Error creating project:', error);
    res.status(500).json({ error: 'Failed to create project' });
  }
});

// Delete a project
app.delete('/api/projects/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`Deleting project: ${id}`);
    
    // Delete all files in the project first
    await db.delete(files).where(eq(files.projectId, id));
    
    // Delete the project
    await db.delete(projects).where(eq(projects.id, id));
    
    console.log(`Project deleted successfully: ${id}`);
    
    broadcast({
      type: 'project_deleted',
      projectId: id
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting project:', error);
    res.status(500).json({ error: 'Failed to delete project' });
  }
});

// Get files for a project
app.get('/api/files', async (req, res) => {
  try {
    const { projectId } = req.query;
    console.log(`Fetching files for project: ${projectId}`);
    
    if (!projectId) {
      return res.status(400).json({ error: 'Project ID is required' });
    }
    
    const projectFiles = await db.select().from(files)
      .where(eq(files.projectId, projectId as string))
      .orderBy(files.path);
    
    console.log(`Found ${projectFiles.length} files`);
    res.json(projectFiles);
  } catch (error) {
    console.error('Error fetching files:', error);
    res.status(500).json({ error: 'Failed to fetch files' });
  }
});

// Create or update a file
app.post('/api/files', async (req, res) => {
  try {
    const { projectId, path: filePath, content } = req.body;
    console.log(`Saving file: ${filePath} for project: ${projectId}`);
    
    if (!projectId || !filePath) {
      return res.status(400).json({ error: 'Project ID and file path are required' });
    }
    
    // Check if file already exists
    const existingFile = await db.select().from(files)
      .where(and(eq(files.projectId, projectId), eq(files.path, filePath)))
      .limit(1);
    
    if (existingFile.length > 0) {
      // Update existing file
      await db.update(files)
        .set({
          content: content || ''
        })
        .where(eq(files.id, existingFile[0].id));
      console.log(`File updated: ${filePath}`);
    } else {
      // Create new file
      await db.insert(files).values({
    id: crypto.randomUUID(),
    projectId,
    path: filePath,
    content: content || '',
    type: 'file'
  } as any);
      console.log(`File created: ${filePath}`);
    }
    
    broadcast({
      type: 'file_updated',
      projectId,
      filePath
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error saving file:', error);
    res.status(500).json({ error: 'Failed to save file' });
  }
});

// Delete a file
app.delete('/api/files/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`Deleting file: ${id}`);
    
    await db.delete(files).where(eq(files.id, id));
    
    console.log(`File deleted successfully: ${id}`);
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting file:', error);
    res.status(500).json({ error: 'Failed to delete file' });
  }
});

// AI Chat endpoint
app.post('/api/ai/chat', async (req, res) => {
  try {
    const { messages, projectId } = req.body;
    console.log(`AI chat request for project: ${projectId}`);
    
    // Mock AI response for now
    res.json({
      response: "I'm a mock AI assistant. This feature will be implemented with actual AI integration.",
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error processing AI chat:', error);
    res.status(500).json({ error: 'AI chat service unavailable' });
  }
});

// Sync endpoint for bolt.diy to push files
app.post('/api/sync/files', async (req, res) => {
  try {
    const { projectId, files: filesList, projectName, framework, template } = req.body;
    
    console.log(`Manual sync request - Project: ${projectId}, Files: ${filesList?.length || 0}`);
    
    if (!projectId) {
      return res.status(400).json({ error: 'Project ID is required' });
    }
    
    // Handle bulk sync
    await handleBulkFileSync({
      projectId,
      files: filesList || [],
      projectName,
      framework,
      template
    });
    
    res.json({ 
      success: true, 
      message: `Synced ${filesList?.length || 0} files for project ${projectId}` 
    });
  } catch (error) {
    console.error('Error in manual sync:', error);
    res.status(500).json({ error: 'Sync failed' });
  }
});

// Get project by ID
app.get('/api/projects/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`Fetching project: ${id}`);
    
    const project = await db.select().from(projects).where(eq(projects.id, id)).limit(1);
    
    if (project.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    // Also get files for this project
    const projectFiles = await db.select().from(files)
      .where(eq(files.projectId, id))
      .orderBy(files.path);
    
    res.json({
      ...project[0],
      files: projectFiles
    });
  } catch (error) {
    console.error('Error fetching project:', error);
    res.status(500).json({ error: 'Failed to fetch project' });
  }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    connections: wsConnections.size 
  });
});

// ============= DYAD UI ROUTE =============
app.get('/dyad', (req, res) => {
  const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dyad AI Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .dashboard { 
            display: flex; 
            height: 100vh; 
            overflow: hidden;
        }
        .header { 
            background: rgba(255,255,255,0.95); 
            backdrop-filter: blur(10px);
            padding: 1rem 2rem; 
            border-bottom: 1px solid rgba(255,255,255,0.2);
            display: flex; 
            align-items: center; 
            justify-content: space-between;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }
        .logo { 
            font-size: 1.5rem; 
            font-weight: bold; 
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .content { 
            flex: 1; 
            padding: 2rem; 
            overflow-y: auto;
            background: rgba(255,255,255,0.1);
        }
        .project-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem;
        }
        .project-card { 
            background: rgba(255,255,255,0.95); 
            backdrop-filter: blur(10px);
            border-radius: 12px; 
            padding: 1.5rem; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .project-card:hover { 
            transform: translateY(-5px); 
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }
        .btn { 
            padding: 0.75rem 1.5rem; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: 500; 
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn-primary { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; 
        }
        .btn-primary:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 25px rgba(102,126,234,0.3);
        }
        .btn-secondary { 
            background: rgba(255,255,255,0.2); 
            color: #333; 
            border: 1px solid rgba(255,255,255,0.3);
        }
        .btn-danger { 
            background: linear-gradient(135deg, #ff6b6b, #ee5a52); 
            color: white; 
        }
        .input { 
            width: 100%; 
            padding: 0.75rem; 
            border: 1px solid rgba(255,255,255,0.3); 
            border-radius: 8px; 
            background: rgba(255,255,255,0.9);
            margin-bottom: 1rem;
        }
        .modal { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.5); 
            backdrop-filter: blur(5px);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            z-index: 1000;
        }
        .modal-content { 
            background: rgba(255,255,255,0.95); 
            backdrop-filter: blur(10px);
            border-radius: 12px; 
            padding: 2rem; 
            max-width: 500px; 
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .file-tree { 
            background: rgba(255,255,255,0.9); 
            border-radius: 8px; 
            padding: 1rem; 
            margin-bottom: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-item { 
            padding: 0.5rem; 
            cursor: pointer; 
            border-radius: 4px; 
            transition: background 0.2s;
        }
        .file-item:hover { 
            background: rgba(102,126,234,0.1); 
        }
        .loading { 
            display: inline-block; 
            width: 20px; 
            height: 20px; 
            border: 3px solid rgba(255,255,255,0.3); 
            border-radius: 50%; 
            border-top-color: #667eea; 
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { 
            to { transform: rotate(360deg); } 
        }
        .sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function DyadDashboard() {
            const [projects, setProjects] = useState([]);
            const [loading, setLoading] = useState(false);
            const [wsConnected, setWsConnected] = useState(false);
            const [syncStatus, setSyncStatus] = useState(null);
            const wsRef = useRef(null);

            useEffect(() => {
                const connectWebSocket = () => {
                    try {
                        const ws = new WebSocket('ws://localhost:9999');
                        wsRef.current = ws;
                        
                        ws.onopen = () => {
                            setWsConnected(true);
                            setSyncStatus({ type: 'success', message: 'Connected to Dyad server' });
                            setTimeout(() => setSyncStatus(null), 3000);
                        };
                        
                        ws.onclose = () => {
                            setWsConnected(false);
                            setSyncStatus({ type: 'error', message: 'Connection lost. Reconnecting...' });
                            setTimeout(connectWebSocket, 3000);
                        };
                        
                        ws.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                console.log('WebSocket message:', data);
                                
                                switch (data.type) {
                                    case 'project_synced':
                                        setSyncStatus({ 
                                            type: 'success', 
                                            message: 'Project synced: ' + data.name
                                        });
                                        loadProjects();
                                        break;
                                    case 'bulk_sync_completed':
                                        setSyncStatus({ 
                                            type: 'success', 
                                            message: data.filesCount + ' files synced!' 
                                        });
                                        loadProjects();
                                        break;
                                }
                                
                                setTimeout(() => setSyncStatus(null), 5000);
                            } catch (error) {
                                console.error('Error parsing WebSocket message:', error);
                            }
                        };

                        ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            setSyncStatus({ type: 'error', message: 'Connection error' });
                        };
                    } catch (error) {
                        console.error('Error creating WebSocket connection:', error);
                        setTimeout(connectWebSocket, 3000);
                    }
                };

                connectWebSocket();

                return () => {
                    if (wsRef.current) {
                        wsRef.current.close();
                    }
                };
            }, []);

            const loadProjects = async () => {
                try {
                    setLoading(true);
                    const response = await axios.get('http://localhost:9999/api/projects');
                    setProjects(response.data);
                } catch (error) {
                    console.error('Error loading projects:', error);
                    setSyncStatus({ type: 'error', message: 'Failed to load projects' });
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => {
                loadProjects();
                const interval = setInterval(loadProjects, 10000);
                return () => clearInterval(interval);
            }, []);

            if (loading) {
                return React.createElement('div', { 
                    style: { 
                        display: 'flex', 
                        justifyContent: 'center', 
                        alignItems: 'center', 
                        height: '100vh',
                        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
                    } 
                }, [
                    React.createElement('div', { className: 'loading', key: 'loading' }),
                    React.createElement('p', { 
                        style: { color: 'white', marginLeft: '1rem' }, 
                        key: 'text' 
                    }, 'Loading projects...')
                ]);
            }

            return React.createElement('div', { className: 'dashboard' }, [
                syncStatus && React.createElement('div', { 
                    className: 'sync-status ' + syncStatus.type, 
                    key: 'sync-status' 
                }, [
                    React.createElement('i', { 
                        className: 'fas ' + (syncStatus.type === 'success' ? 'fa-check-circle' : 
                                           syncStatus.type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'),
                        key: 'icon'
                    }),
                    ' ' + syncStatus.message
                ]),
                
                React.createElement('div', { style: { width: '100%' }, key: 'main' }, [
                    React.createElement('div', { className: 'header', key: 'header' }, [
                        React.createElement('h1', { className: 'logo', key: 'logo' }, [
                            React.createElement('i', { className: 'fas fa-cube', key: 'icon' }),
                            ' Dyad Dashboard'
                        ]),
                        React.createElement('div', { 
                            style: { display: 'flex', gap: '1rem', alignItems: 'center' },
                            key: 'status'
                        }, [
                            React.createElement('div', { 
                                style: { fontSize: '0.9rem', color: wsConnected ? '#4CAF50' : '#f44336' },
                                key: 'ws-status'
                            }, [
                                React.createElement('i', { 
                                    className: 'fas ' + (wsConnected ? 'fa-wifi' : 'fa-wifi-slash'),
                                    key: 'ws-icon'
                                }),
                                wsConnected ? ' Live Sync Active' : ' Offline'
                            ])
                        ])
                    ]),
                    
                    React.createElement('div', { className: 'content', key: 'content' }, [
                        projects.length === 0 ? 
                        React.createElement('div', { 
                            style: { textAlign: 'center', padding: '2rem', color: 'white' },
                            key: 'empty-state'
                        }, [
                            React.createElement('i', { 
                                className: 'fas fa-folder-plus', 
                                style: { fontSize: '3rem', marginBottom: '1rem' },
                                key: 'icon'
                            }),
                            React.createElement('h3', { key: 'title' }, 'No Projects Yet'),
                            React.createElement('p', { key: 'desc1' }, 'Create a project in bolt.diy to get started.'),
                            React.createElement('p', { 
                                style: { marginTop: '1rem', fontSize: '0.9rem', opacity: 0.8 },
                                key: 'desc2'
                            }, 'Projects created in bolt.diy will automatically sync here when you save files.')
                        ]) :
                        React.createElement('div', { key: 'projects-container' }, [
                            React.createElement('h2', { 
                                style: { color: 'white', marginBottom: '1.5rem' },
                                key: 'title'
                            }, 'Your Projects (' + projects.length + ')'),
                            React.createElement('div', { className: 'project-grid', key: 'grid' },
                                projects.map(project => 
                                    React.createElement('div', { 
                                        key: project.id, 
                                        className: 'project-card',
                                        onClick: () => window.open('/api/projects/' + project.id, '_blank')
                                    }, [
                                        React.createElement('h3', { key: 'name' }, project.name),
                                        React.createElement('p', { 
                                            style: { color: '#666', margin: '0.5rem 0' },
                                            key: 'desc'
                                        }, project.description || 'No description'),
                                        React.createElement('div', { 
                                            style: { 
                                                display: 'flex', 
                                                justifyContent: 'space-between', 
                                                alignItems: 'center', 
                                                marginTop: '1rem',
                                                fontSize: '0.8rem',
                                                color: '#888'
                                            },
                                            key: 'meta'
                                        }, [
                                            React.createElement('div', { key: 'tags' }, [
                                                React.createElement('span', { 
                                                    style: { 
                                                        background: '#667eea', 
                                                        color: 'white', 
                                                        padding: '0.25rem 0.5rem', 
                                                        borderRadius: '4px', 
                                                        fontSize: '0.8rem',
                                                        marginRight: '0.5rem'
                                                    },
                                                    key: 'framework'
                                                }, project.framework || 'unknown'),
                                                project.template && React.createElement('span', { 
                                                    style: { 
                                                        background: '#6c757d', 
                                                        color: 'white', 
                                                        padding: '0.25rem 0.5rem', 
                                                        borderRadius: '4px', 
                                                        fontSize: '0.8rem'
                                                    },
                                                    key: 'template'
                                                }, project.template)
                                            ])
                                        ]),
                                        React.createElement('div', { 
                                            style: { 
                                                fontSize: '0.7rem', 
                                                color: '#999', 
                                                marginTop: '0.5rem',
                                                textAlign: 'right'
                                            },
                                            key: 'created'
                                        }, 'Created: ' + new Date(project.createdAt * 1000).toLocaleDateString())
                                    ])
                                )
                            )
                        ])
                    ])
                ])
            ]);
        }

        ReactDOM.render(React.createElement(DyadDashboard), document.getElementById('root'));
    </script>
</body>
</html>`;
  
  res.send(htmlContent);
});

// Initialize database and start server
async function startServer() {
  try {
    console.log('Dyad Backend Server Starting!');
    console.log('HTTP API: http://localhost:' + PORT);
    console.log('WebSocket: ws://localhost:' + PORT);
    console.log('Dyad UI: http://localhost:' + PORT + '/dyad');
    console.log('Initializing database...');
    
    await initializeDatabase();
    
    console.log('Database initialized successfully!');
    console.log('Ready to accept connections from bolt.diy');
    console.log('CORS enabled for: http://localhost:5173, http://localhost:3000');
    
    server.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();









// import express from 'express';
// import cors from 'cors';
// import { WebSocketServer } from 'ws';
// import { createServer } from 'http';
// import { db, initializeDatabase } from '../db';
// import { projects, files } from '../db/schema';
// import { eq, and } from 'drizzle-orm';
// import path from "path";
// import crypto from 'crypto';
// import axios from 'axios';

// const app = express();
// const server = createServer(app);
// const PORT = 9999;

// // Ollama configuration
// const OLLAMA_BASE_URL = 'http://localhost:11434';
// const DEFAULT_MODEL = 'llama3.1';

// // Bolt.diy configuration
// const BOLT_BASE_URL = 'http://localhost:5173';
// const BOLT_WEBHOOK_SECRET = 'dyad-bolt-webhook-secret';

// app.use(cors({
//   origin: ['http://localhost:5173', 'http://localhost:3000', 'http://localhost:5174'], // bolt.diy servers
//   credentials: true,
//   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
//   allowedHeaders: ['Content-Type', 'Authorization', 'X-Webhook-Secret']
// }));

// app.use(express.json({ limit: '50mb' }));
// app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// // Initialize WebSocket server
// const wss = new WebSocketServer({ server });

// // Store active connections with metadata
// const activeConnections = new Map();

// wss.on('connection', (ws, req) => {
//   const clientId = crypto.randomUUID();
//   console.log('üîå New WebSocket connection from:', req.socket.remoteAddress, `(${clientId})`);
  
//   activeConnections.set(clientId, {
//     ws,
//     projectId: null,
//     lastActivity: new Date(),
//     source: 'unknown'
//   });
  
//   ws.on('message', async (message) => {
//     try {
//       const data = JSON.parse(message.toString());
//       console.log('üì® WebSocket message:', data.type, 'from', clientId);
      
//       const connection = activeConnections.get(clientId);
//       if (connection) {
//         connection.lastActivity = new Date();
//         connection.projectId = data.projectId || connection.projectId;
//         connection.source = data.source || connection.source;
//       }
      
//       // Handle different message types
//       switch (data.type) {
//         case 'subscribe_project':
//           if (connection) {
//             connection.projectId = data.projectId;
//           }
//           break;
          
//         case 'file_change':
//           await handleFileChange(data);
//           broadcastToProject(data.projectId, data, ws);
//           break;
          
//         case 'bolt_project_sync':
//           await handleBoltProjectSync(data);
//           break;
          
//         case 'ai_request':
//           await handleAIRequest(data, ws);
//           break;
          
//         case 'ping':
//           ws.send(JSON.stringify({ type: 'pong', timestamp: new Date().toISOString() }));
//           break;
//       }
//     } catch (error) {
//       console.error('‚ùå Error processing WebSocket message:', error);
//       ws.send(JSON.stringify({ 
//         type: 'error', 
//         message: error.message,
//         timestamp: new Date().toISOString()
//       }));
//     }
//   });
  
//   ws.on('close', () => {
//     console.log('üîå WebSocket connection closed:', clientId);
//     activeConnections.delete(clientId);
//   });

//   ws.on('error', (error) => {
//     console.error('üîå WebSocket error:', error);
//     activeConnections.delete(clientId);
//   });
// });

// // ============= HELPER FUNCTIONS =============

// function getFileType(filePath: string): string {
//   const ext = path.extname(filePath).toLowerCase();
//   const typeMap: { [key: string]: string } = {
//     '.js': 'javascript',
//     '.jsx': 'react',
//     '.ts': 'typescript',
//     '.tsx': 'react-typescript',
//     '.css': 'css',
//     '.scss': 'scss',
//     '.sass': 'sass',
//     '.less': 'less',
//     '.html': 'html',
//     '.htm': 'html',
//     '.xml': 'xml',
//     '.json': 'json',
//     '.md': 'markdown',
//     '.txt': 'text',
//     '.py': 'python',
//     '.php': 'php',
//     '.java': 'java',
//     '.cpp': 'cpp',
//     '.c': 'c',
//     '.cs': 'csharp',
//     '.go': 'go',
//     '.rs': 'rust',
//     '.rb': 'ruby',
//     '.vue': 'vue',
//     '.svelte': 'svelte',
//     '.yaml': 'yaml',
//     '.yml': 'yaml',
//     '.toml': 'toml',
//     '.ini': 'ini',
//     '.conf': 'config',
//     '.env': 'env',
//     '.gitignore': 'gitignore',
//     '.dockerfile': 'dockerfile',
//     '.sql': 'sql',
//     '.sh': 'shell',
//     '.bash': 'shell',
//     '.zsh': 'shell',
//     '.fish': 'shell',
//     '.ps1': 'powershell',
//     '.bat': 'batch',
//     '.cmd': 'batch'
//   };
  
//   return typeMap[ext] || 'text';
// }

// function getInitialFiles(framework: string, projectName: string): Array<{path: string, content: string}> {
//   const files: Array<{path: string, content: string}> = [];
  
//   switch (framework) {
//     case 'react':
//       files.push(
//         {
//           path: 'package.json',
//           content: JSON.stringify({
//             "name": projectName.toLowerCase().replace(/\s+/g, '-'),
//             "private": true,
//             "version": "0.0.0",
//             "type": "module",
//             "scripts": {
//               "dev": "vite",
//               "build": "tsc && vite build",
//               "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
//               "preview": "vite preview"
//             },
//             "dependencies": {
//               "react": "^18.2.0",
//               "react-dom": "^18.2.0"
//             },
//             "devDependencies": {
//               "@types/react": "^18.2.66",
//               "@types/react-dom": "^18.2.22",
//               "@typescript-eslint/eslint-plugin": "^7.2.0",
//               "@typescript-eslint/parser": "^7.2.0",
//               "@vitejs/plugin-react": "^4.2.1",
//               "eslint": "^8.57.0",
//               "eslint-plugin-react-hooks": "^4.6.0",
//               "eslint-plugin-react-refresh": "^0.4.6",
//               "typescript": "^5.2.2",
//               "vite": "^5.2.0"
//             }
//           }, null, 2)
//         },
//         {
//           path: 'index.html',
//           content: `<!doctype html>
// <html lang="en">
//   <head>
//     <meta charset="UTF-8" />
//     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
//     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
//     <title>${projectName}</title>
//   </head>
//   <body>
//     <div id="root"></div>
//     <script type="module" src="/src/main.tsx"></script>
//   </body>
// </html>`
//         },
//         {
//           path: 'src/main.tsx',
//           content: `import React from 'react'
// import ReactDOM from 'react-dom/client'
// import App from './App.tsx'
// import './index.css'

// ReactDOM.createRoot(document.getElementById('root')!).render(
//   <React.StrictMode>
//     <App />
//   </React.StrictMode>,
// )`
//         },
//         {
//           path: 'src/App.tsx',
//           content: `import { useState } from 'react'
// import './App.css'

// function App() {
//   const [count, setCount] = useState(0)

//   return (
//     <>
//       <div className="app">
//         <h1>${projectName}</h1>
//         <div className="card">
//           <button onClick={() => setCount((count) => count + 1)}>
//             count is {count}
//           </button>
//           <p>
//             Edit <code>src/App.tsx</code> and save to test HMR
//           </p>
//         </div>
//         <p className="read-the-docs">
//           Click on the Vite and React logos to learn more
//         </p>
//       </div>
//     </>
//   )
// }

// export default App`
//         },
//         {
//           path: 'src/App.css',
//           content: `#root {
//   max-width: 1280px;
//   margin: 0 auto;
//   padding: 2rem;
//   text-align: center;
// }

// .app {
//   height: 100vh;
//   display: flex;
//   flex-direction: column;
//   align-items: center;
//   justify-content: center;
// }

// .card {
//   padding: 2em;
// }

// .read-the-docs {
//   color: #888;
// }`
//         },
//         {
//           path: 'src/index.css',
//           content: `:root {
//   font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
//   line-height: 1.5;
//   font-weight: 400;

//   color-scheme: light dark;
//   color: rgba(255, 255, 255, 0.87);
//   background-color: #242424;

//   font-synthesis: none;
//   text-rendering: optimizeLegibility;
//   -webkit-font-smoothing: antialiased;
//   -moz-osx-font-smoothing: grayscale;
//   -webkit-text-size-adjust: 100%;
// }

// body {
//   margin: 0;
//   display: flex;
//   place-items: center;
//   min-width: 320px;
//   min-height: 100vh;
// }

// h1 {
//   font-size: 3.2em;
//   line-height: 1.1;
// }

// button {
//   border-radius: 8px;
//   border: 1px solid transparent;
//   padding: 0.6em 1.2em;
//   font-size: 1em;
//   font-weight: 500;
//   font-family: inherit;
//   background-color: #1a1a1a;
//   color: white;
//   cursor: pointer;
//   transition: border-color 0.25s;
// }
// button:hover {
//   border-color: #646cff;
// }
// button:focus,
// button:focus-visible {
//   outline: 4px auto -webkit-focus-ring-color;
// }

// @media (prefers-color-scheme: light) {
//   :root {
//     color: #213547;
//     background-color: #ffffff;
//   }
//   button {
//     background-color: #f9f9f9;
//     color: #213547;
//   }
// }`
//         }
//       );
//       break;
      
//     case 'vue':
//       files.push(
//         {
//           path: 'package.json',
//           content: JSON.stringify({
//             "name": projectName.toLowerCase().replace(/\s+/g, '-'),
//             "private": true,
//             "version": "0.0.0",
//             "type": "module",
//             "scripts": {
//               "dev": "vite",
//               "build": "vue-tsc && vite build",
//               "preview": "vite preview"
//             },
//             "dependencies": {
//               "vue": "^3.3.11"
//             },
//             "devDependencies": {
//               "@vitejs/plugin-vue": "^4.5.2",
//               "typescript": "^5.2.2",
//               "vite": "^5.0.8",
//               "vue-tsc": "^1.8.25"
//             }
//           }, null, 2)
//         },
//         {
//           path: 'src/App.vue',
//           content: `<template>
//   <div id="app">
//     <h1>{{ title }}</h1>
//     <button @click="increment">Count: {{ count }}</button>
//   </div>
// </template>

// <script setup lang="ts">
// import { ref } from 'vue'

// const title = ref('${projectName}')
// const count = ref(0)

// const increment = () => {
//   count.value++
// }
// </script>

// <style scoped>
// #app {
//   font-family: Avenir, Helvetica, Arial, sans-serif;
//   text-align: center;
//   color: #2c3e50;
//   margin-top: 60px;
// }

// button {
//   background-color: #4caf50;
//   border: none;
//   color: white;
//   padding: 15px 32px;
//   text-align: center;
//   text-decoration: none;
//   display: inline-block;
//   font-size: 16px;
//   margin: 4px 2px;
//   cursor: pointer;
//   border-radius: 4px;
// }
// </style>`
//         }
//       );
//       break;
      
//     default:
//       files.push(
//         {
//           path: 'index.html',
//           content: `<!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>${projectName}</title>
//     <link rel="stylesheet" href="style.css">
// </head>
// <body>
//     <div class="container">
//         <h1>${projectName}</h1>
//         <p>Welcome to your new project!</p>
//         <button id="btn">Click me!</button>
//     </div>
//     <script src="script.js"></script>
// </body>
// </html>`
//         },
//         {
//           path: 'style.css',
//           content: `body {
//     font-family: Arial, sans-serif;
//     margin: 0;
//     padding: 0;
//     background-color: #f0f0f0;
// }

// .container {
//     max-width: 800px;
//     margin: 0 auto;
//     padding: 20px;
//     text-align: center;
// }

// h1 {
//     color: #333;
// }

// button {
//     background-color: #007bff;
//     color: white;
//     border: none;
//     padding: 10px 20px;
//     font-size: 16px;
//     border-radius: 4px;
//     cursor: pointer;
// }

// button:hover {
//     background-color: #0056b3;
// }`
//         },
//         {
//           path: 'script.js',
//           content: `document.addEventListener('DOMContentLoaded', function() {
//     const button = document.getElementById('btn');
//     let clickCount = 0;
    
//     button.addEventListener('click', function() {
//         clickCount++;
//         button.textContent = \`Clicked \${clickCount} times!\`;
//     });
// });`
//         }
//       );
//   }
  
//   return files;
// }

// // Fixed cleanup function to work with TypeScript
// function cleanupInactiveConnections() {
//   const now = new Date();
//   const clientsToRemove: string[] = [];
  
//   activeConnections.forEach((connection, clientId) => {
//     const timeDiff = now.getTime() - connection.lastActivity.getTime();
//     if (timeDiff > 300000) { // 5 minutes
//       console.log('üßπ Cleaning up inactive connection:', clientId);
//       connection.ws.terminate();
//       clientsToRemove.push(clientId);
//     }
//   });
  
//   clientsToRemove.forEach(clientId => {
//     activeConnections.delete(clientId);
//   });
// }

// // Fixed broadcastToProject function
// function broadcastToProject(projectId: string, message: any, sender?: any) {
//   let count = 0;
//   const clientsToRemove: string[] = [];
  
//   activeConnections.forEach((connection, clientId) => {
//     if (connection.ws !== sender && 
//         connection.ws.readyState === 1 && 
//         connection.projectId === projectId) {
//       try {
//         connection.ws.send(JSON.stringify(message));
//         count++;
//       } catch (error) {
//         console.error('‚ùå Error broadcasting to client:', clientId, error.message);
//         clientsToRemove.push(clientId);
//       }
//     }
//   });
  
//   clientsToRemove.forEach(clientId => {
//     activeConnections.delete(clientId);
//   });
  
//   if (count > 0) {
//     console.log(`üì° Broadcasted message to ${count} clients for project:`, projectId);
//   }
// }

// function broadcastToAll(message: any) {
//   let count = 0;
//   const clientsToRemove: string[] = [];
  
//   activeConnections.forEach((connection, clientId) => {
//     if (connection.ws.readyState === 1) {
//       try {
//         connection.ws.send(JSON.stringify(message));
//         count++;
//       } catch (error) {
//         console.error('‚ùå Error broadcasting to client:', clientId, error.message);
//         clientsToRemove.push(clientId);
//       }
//     }
//   });
  
//   clientsToRemove.forEach(clientId => {
//     activeConnections.delete(clientId);
//   });
  
//   if (count > 0) {
//     console.log(`üì° Broadcasted message to ${count} clients`);
//   }
// }

// // Fixed createProjectFromBolt to match your schema
// async function createProjectFromBolt(boltProject: any) {
//   try {
//     const projectId = crypto.randomUUID();
//     console.log('üìÅ Creating project from Bolt.diy:', boltProject.name);
    
//     // Insert project - using only fields that exist in your schema
//     await db.insert(projects).values({
//       id: projectId,
//       name: boltProject.name || 'Imported from Bolt',
//     //   template: boltProject.framework || 'react',
//       framework: detectFramework(boltProject.files) || 'react',
//       devServerPort: 3000,
//       devServerPid: 0,
//       isRunning: false,
//       createdAt: new Date(),
//       updatedAt: new Date()
//     } as any);

//     // Insert files if they exist - remove 'type' field as it doesn't exist
//     if (boltProject.files && Array.isArray(boltProject.files)) {
//       for (const file of boltProject.files) {
//         await db.insert(files).values({
//           id: crypto.randomUUID(),
//           projectId: projectId,
//           path: file.path || file.name || 'untitled.js',
//           content: file.content || '',
//           createdAt: new Date(),
//           updatedAt: new Date()
//         } as any);
//       }
//     }

//     console.log(`‚úÖ Created project from Bolt: ${boltProject.name} (${projectId})`);
    
//     // Notify Bolt.diy of successful creation
//     try {
//       await axios.post(`${BOLT_BASE_URL}/api/dyad/project-created`, {
//         dyadProjectId: projectId,
//         boltProjectId: boltProject.id,
//         name: boltProject.name
//       }, {
//         headers: { 'X-Webhook-Secret': BOLT_WEBHOOK_SECRET },
//         timeout: 5000
//       });
//     } catch (webhookError: any) {
//       console.log('üì° Could not notify Bolt.diy (this is normal):', webhookError.message);
//     }
    
//     return projectId;
//   } catch (error) {
//     console.error('‚ùå Error creating project from Bolt:', error);
//     throw error;
//   }
// }

// async function updateFilesFromBolt(projectId: string, boltFiles: any[]) {
//   try {
//     console.log(`üìù Updating ${boltFiles.length} files from Bolt for project:`, projectId);
    
//     for (const file of boltFiles) {
//       // Check if file exists
//       const existingFile = await db.query.files.findFirst({
//         where: and(
//           eq(files.projectId, projectId),
//           eq(files.path, file.path)
//         )
//       });

//       if (existingFile) {
//         // Update existing file
//         await db.update(files)
//           .set({ 
//             content: file.content,
//             updatedAt: new Date()
//           })
//           .where(eq(files.id, existingFile.id));
//       } else {
//         // Create new file - remove type field
//         await db.insert(files).values({
//           id: crypto.randomUUID(),
//           projectId: projectId,
//           path: file.path,
//           content: file.content || '',
//           createdAt: new Date(),
//           updatedAt: new Date()
//         } as any);
//       }
//     }
    
//     console.log(`‚úÖ Updated ${boltFiles.length} files from Bolt`);
//   } catch (error) {
//     console.error('‚ùå Error updating files from Bolt:', error);
//     throw error;
//   }
// }

// async function sendProjectToBolt(projectId: string) {
//   try {
//     const project = await db.query.projects.findFirst({
//       where: eq(projects.id, projectId)
//     });

//     if (!project) {
//       throw new Error('Project not found');
//     }

//     const projectFiles = await db.query.files.findMany({
//       where: eq(files.projectId, projectId)
//     });

//     // Format for Bolt.diy - use available fields
//     const boltData = {
//       id: crypto.randomUUID(), // Generate new ID
//       name: project.name,
//       description: `Project exported from Dyad`, // Default description
//       framework: detectFramework(projectFiles), // Detect from files
//       files: projectFiles.map(file => ({
//         path: file.path,
//         content: file.content,
//         type: getFileType(file.path) // Calculate type from path
//       })),
//       createdAt: project.createdAt,
//       updatedAt: new Date()
//     };

//     // Send to Bolt.diy
//     await axios.post(`${BOLT_BASE_URL}/api/dyad/import-project`, boltData, {
//       headers: { 'X-Webhook-Secret': BOLT_WEBHOOK_SECRET },
//       timeout: 10000
//     });

//     console.log(`‚úÖ Sent project to Bolt.diy: ${project.name}`);
//   } catch (error) {
//     console.error('‚ùå Error sending project to Bolt:', error);
//     throw error;
//   }
// }

// // ============= BOLT.DIY INTEGRATION FUNCTIONS =============

// async function handleBoltProjectSync(data: any) {
//   try {
//     console.log('üîÑ Handling Bolt project sync:', data.action);
    
//     switch (data.action) {
//       case 'project_created':
//         await createProjectFromBolt(data.project);
//         break;
        
//       case 'files_updated':
//         await updateFilesFromBolt(data.projectId, data.files);
//         break;
        
//       case 'project_request':
//         await sendProjectToBolt(data.projectId);
//         break;
//     }
    
//     // Broadcast update to all connected clients
//     broadcastToAll({
//       type: 'bolt_sync_complete',
//       action: data.action,
//       projectId: data.projectId,
//       timestamp: new Date().toISOString()
//     });
//   } catch (error) {
//     console.error('‚ùå Error handling Bolt sync:', error);
//     throw error;
//   }
// }

// // ============= AI INTEGRATION FUNCTIONS =============

// async function handleAIRequest(data: any, ws: any) {
//   try {
//     console.log('ü§ñ Processing AI request for project:', data.projectId);
    
//     const response = await processAIRequest({
//       message: data.message,
//       projectId: data.projectId,
//       model: data.model || DEFAULT_MODEL,
//       context: data.context || {}
//     });
    
//     ws.send(JSON.stringify({
//       type: 'ai_response',
//       requestId: data.requestId,
//       response: response.response,
//       fileChanges: response.fileChanges,
//       model: response.model,
//       timestamp: new Date().toISOString()
//     }));
    
//     // If AI made file changes, broadcast to other clients
//     if (response.fileChanges && response.fileChanges.length > 0) {
//       broadcastToProject(data.projectId, {
//         type: 'file_update',
//         projectId: data.projectId,
//         fileChanges: response.fileChanges,
//         source: 'ai',
//         timestamp: new Date().toISOString()
//       }, ws);
//     }
//   } catch (error) {
//     console.error('‚ùå Error handling AI request:', error);
//     ws.send(JSON.stringify({
//       type: 'ai_error',
//       requestId: data.requestId,
//       error: error.message,
//       timestamp: new Date().toISOString()
//     }));
//   }
// }

// async function processAIRequest(params: {
//   message: string;
//   projectId: string;
//   model: string;
//   context: any;
// }) {
//   const { message, projectId, model, context } = params;
  
//   // Get project context
//   const project = await db.query.projects.findFirst({
//     where: eq(projects.id, projectId),
//   });

//   if (!project) {
//     throw new Error('Project not found');
//   }

//   // Get all current files for context
//   const currentFiles = await db.query.files.findMany({
//     where: eq(files.projectId, projectId)
//   });

//   // Build comprehensive context for the AI
//   const projectContext = `Project: ${project.name}
// Framework: ${project.framework}

// Current files in project:
// ${currentFiles.map(f => `- ${f.path} (${f.content?.length || 0} chars)`).join('\n')}
// `;

//   const fileContents = currentFiles.map(f => `
// File: ${f.path}
// \`\`\`${getFileExtension(f.path)}
// ${f.content || '// Empty file'}
// \`\`\`
// `).join('\n');

//   // Create system prompt for code assistance
//   const systemPrompt = `You are Dyad AI, an expert coding assistant integrated with Bolt.diy. You help developers by:

// 1. Analyzing and fixing code errors
// 2. Suggesting improvements and optimizations  
// 3. Adding new features and functionality
// 4. Explaining code concepts
// 5. Generating code based on requirements

// IMPORTANT: When you need to update or create files, provide the COMPLETE file content wrapped in triple backticks with the file extension, like this:

// \`\`\`javascript
// // Complete file content here
// \`\`\`

// For multiple files, use this format:
// File: src/components/NewComponent.jsx
// \`\`\`jsx
// // Complete component code
// \`\`\`

// File: src/styles/component.css
// \`\`\`css
// /* Complete CSS */
// \`\`\`

// Context: ${projectContext}

// Current file contents:
// ${fileContents}

// User request: ${message}`;

//   try {
//     // Call Ollama API
//     const ollamaResponse = await axios.post(`${OLLAMA_BASE_URL}/api/generate`, {
//       model: model,
//       prompt: systemPrompt,
//       stream: false,
//       options: {
//         temperature: 0.1,
//         top_p: 0.9,
//         top_k: 40,
//         num_predict: 4096 // Allow longer responses for code
//       }
//     }, { timeout: 60000 }); // 60 second timeout

//     const aiResponse = ollamaResponse.data.response;
//     console.log('‚úÖ AI response generated using model:', model);

//     // Parse AI response for potential file changes
//     const fileChanges = await parseAIResponseForFileChanges(aiResponse, projectId, currentFiles);

//     return { 
//       response: aiResponse,
//       fileChanges: fileChanges,
//       model: model,
//       timestamp: new Date().toISOString()
//     };

//   } catch (ollamaError: any) {
//     console.error('‚ùå Ollama API error:', ollamaError.message);
    
//     // Fallback response if Ollama is unavailable
//     const fallbackResponse = `I'm having trouble connecting to the Ollama AI service. Here's what I can help you with:

// **For the message**: "${message}"

// **Troubleshooting Steps:**
// 1. Check that Ollama is running: \`ollama serve\`
// 2. Verify the model is installed: \`ollama list\`
// 3. Test the connection: \`curl http://localhost:11434/api/version\`

// **General Coding Help:**
// - Check for syntax errors (missing semicolons, brackets)
// - Verify import statements are correct
// - Ensure all variables are properly declared
// - Check for typos in function/variable names
// - Consider error handling and edge cases

// Please ensure Ollama is running on localhost:11434 with the ${model} model for full AI capabilities.`;

//     return { 
//       response: fallbackResponse,
//       fileChanges: [],
//       model: 'fallback',
//       error: 'Ollama service unavailable: ' + ollamaError.message
//     };
//   }
// }

// // Enhanced function to parse AI responses for file changes
// async function parseAIResponseForFileChanges(response: string, projectId: string, currentFiles: any[]): Promise<any[]> {
//   const fileChanges: any[] = [];
  
//   try {
//     // Look for file patterns in the response
//     const filePatterns = [
//       // Pattern: File: path/to/file.ext
//       /File:\s*([^\n]+)\n```([a-zA-Z]*)\n([\s\S]*?)```/g,
//       // Pattern: ```language (with file comment)
//       /(?:\/\/\s*File:\s*([^\n]+)\n|\/\*\s*File:\s*([^\n]+)\s*\*\/\n)?```([a-zA-Z]*)\n([\s\S]*?)```/g
//     ];
    
//     for (const pattern of filePatterns) {
//       let match;
//       while ((match = pattern.exec(response)) !== null) {
//         let filePath = match[1] || match[2];
//         let language = match[2] || match[3];
//         let content = match[3] || match[4];
        
//         if (!filePath && language && content) {
//           // Try to infer file path from content or use a default
//           if (language === 'jsx' || language === 'tsx') {
//             filePath = 'src/App.' + language;
//           } else if (language === 'css') {
//             filePath = 'src/App.css';
//           } else if (language === 'javascript' || language === 'js') {
//             filePath = 'src/index.js';
//           } else if (language === 'html') {
//             filePath = 'index.html';
//           } else {
//             filePath = 'generated-file.' + (language || 'txt');
//           }
//         }
        
//         if (filePath && content) {
//           // Clean up the file path
//           filePath = filePath.trim();
//           if (filePath.startsWith('./')) {
//             filePath = filePath.substring(2);
//           }
          
//           // Clean up content
//           content = content.trim();
          
//           fileChanges.push({
//             path: filePath,
//             content: content,
//             action: 'update'
//           });
          
//           // Actually update the file in the database
//           try {
//             const existingFile = await db.query.files.findFirst({
//               where: and(
//                 eq(files.projectId, projectId),
//                 eq(files.path, filePath)
//               )
//             });

//             if (existingFile) {
//               // Update existing file
//               await db.update(files)
//                 .set({ 
//                   content: content,
//                   updatedAt: new Date()
//                 })
//                 .where(eq(files.id, existingFile.id));
              
//               console.log(`‚úÖ AI updated existing file: ${filePath}`);
//             } else {
//               // Create new file
//               await db.insert(files).values({
//                 id: crypto.randomUUID(),
//                 projectId: projectId,
//                 path: filePath,
//                 content: content,
//                 createdAt: new Date(),
//                 updatedAt: new Date()
//               } as any);
              
//               console.log(`‚úÖ AI created new file: ${filePath}`);
//             }
//           } catch (dbError) {
//             console.error('‚ùå Error updating file from AI response:', dbError);
//           }
//         }
//       }
//     }
    
//     // Also update project timestamp
//     if (fileChanges.length > 0) {
//       await db.update(projects)
//         .set({ updatedAt: new Date() })
//         .where(eq(projects.id, projectId));
//     }
    
//     console.log(`ü§ñ AI processed ${fileChanges.length} file changes`);
    
//   } catch (error) {
//     console.error('‚ùå Error parsing AI response for file changes:', error);
//   }
  
//   return fileChanges;
// }

// // ============= WEBHOOK ENDPOINTS FOR BOLT.DIY =============

// // Webhook to receive updates from Bolt.diy
// app.post('/api/bolt/webhook', async (req, res) => {
//   try {
//     const webhookSecret = req.headers['x-webhook-secret'];
//     if (webhookSecret !== BOLT_WEBHOOK_SECRET) {
//       return res.status(401).json({ error: 'Invalid webhook secret' });
//     }
    
//     const { action, project, files: boltFiles, projectId } = req.body;
//     console.log('üîó Bolt webhook received:', action);
    
//     let result = null;
    
//     switch (action) {
//       case 'project_created':
//         result = await createProjectFromBolt(project);
//         broadcastToAll({
//           type: 'bolt_project_created',
//           projectId: result,
//           projectName: project.name,
//           timestamp: new Date().toISOString()
//         });
//         break;
        
//       case 'files_updated':
//         if (projectId) {
//           await updateFilesFromBolt(projectId, boltFiles);
//           broadcastToProject(projectId, {
//             type: 'file_update',
//             projectId: projectId,
//             fileChanges: boltFiles.map(f => ({ path: f.path })),
//             source: 'bolt',
//             timestamp: new Date().toISOString()
//           });
//         }
//         break;
        
//       case 'project_request':
//         await sendProjectToBolt(projectId);
//         break;
//     }
    
//     res.json({ success: true, result });
//   } catch (error) {
//     console.error('‚ùå Error handling Bolt webhook:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Endpoint for Bolt.diy to check connection
// app.get('/api/bolt/status', (req, res) => {
//   res.json({ 
//     status: 'connected',
//     timestamp: new Date().toISOString(),
//     activeConnections: activeConnections.size,
//     ollamaConnected: false // Will be updated by status check
//   });
// });

// // ============= OLLAMA INTEGRATION ENDPOINTS =============

// // Check Ollama status
// app.get('/api/ai/status', async (req, res) => {
//   try {
//     const response = await axios.get(`${OLLAMA_BASE_URL}/api/tags`, { timeout: 5000 });
//     res.json({ 
//       connected: true, 
//       models: response.data.models || [],
//       baseUrl: OLLAMA_BASE_URL,
//       defaultModel: DEFAULT_MODEL
//     });
//   } catch (error: any) {
//     res.json({ 
//       connected: false, 
//       error: error.message,
//       baseUrl: OLLAMA_BASE_URL,
//       defaultModel: DEFAULT_MODEL
//     });
//   }
// });

// // Get available models
// app.get('/api/ai/models', async (req, res) => {
//   try {
//     const response = await axios.get(`${OLLAMA_BASE_URL}/api/tags`, { timeout: 5000 });
//     const models = response.data.models?.map((model: any) => ({
//       name: model.name,
//       size: model.size,
//       modified_at: model.modified_at
//     })) || [];
//     res.json({ models });
//   } catch (error: any) {
//     console.error('Error fetching Ollama models:', error);
//     res.status(500).json({ error: error.message, models: [] });
//   }
// });

// // Enhanced AI chat endpoint with Ollama integration
// app.post('/api/ai/chat', async (req, res) => {
//   try {
//     const { message, projectId, model = DEFAULT_MODEL, context = {} } = req.body;
//     console.log('ü§ñ AI chat request for project:', projectId, 'using model:', model);
    
//     if (!projectId) {
//       return res.status(400).json({ error: 'Project ID is required' });
//     }

//     const response = await processAIRequest({
//       message,
//       projectId,
//       model,
//       context
//     });

//     res.json(response);
//   } catch (error: any) {
//     console.error('‚ùå Error in AI chat:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // ============= EXISTING PROJECT AND FILE ENDPOINTS =============

// // Get all projects
// app.get('/api/projects', async (req, res) => {
//   try {
//     console.log('üìÇ Fetching all projects...');
//     const allProjects = await db.query.projects.findMany({
//       orderBy: (projects, { desc }) => [desc(projects.updatedAt)]
//     });
//     console.log(`üìä Found ${allProjects.length} projects`);
//     res.json(allProjects);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching projects:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Create new project
// app.post('/api/projects', async (req, res) => {
//   try {
//     const { name, framework = 'react' } = req.body;
//     console.log('üìÅ Creating new project:', name);
    
//     const projectId = crypto.randomUUID();
    
//     await db.insert(projects).values({
//       id: projectId,
//       name,
//       template: framework,
//       framework,
//       devServerPort: 3000,
//       devServerPid: 0,
//       isRunning: false,
//       createdAt: new Date(),
//       updatedAt: new Date()
//     } as any);

//     // Create initial files based on framework
//     const initialFiles = getInitialFiles(framework, name);
//     for (const file of initialFiles) {
//       await db.insert(files).values({
//         id: crypto.randomUUID(),
//         projectId: projectId,
//         path: file.path,
//         content: file.content,
//         createdAt: new Date(),
//         updatedAt: new Date()
//       } as any);
//     }

//     const newProject = await db.query.projects.findFirst({
//       where: eq(projects.id, projectId)
//     });

//     console.log(`‚úÖ Created project: ${name} (${projectId})`);
    
//     // Broadcast to all clients
//     broadcastToAll({
//       type: 'project_created',
//       project: newProject,
//       timestamp: new Date().toISOString()
//     });
    
//     res.json(newProject);
//   } catch (error: any) {
//     console.error('‚ùå Error creating project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Delete project
// app.delete('/api/projects/:id', async (req, res) => {
//   try {
//     const projectId = req.params.id;
//     console.log('üóëÔ∏è Deleting project:', projectId);
    
//     // Delete all files first
//     await db.delete(files).where(eq(files.projectId, projectId));
    
//     // Delete project
//     await db.delete(projects).where(eq(projects.id, projectId));
    
//     console.log(`‚úÖ Deleted project: ${projectId}`);
    
//     // Broadcast deletion
//     broadcastToAll({
//       type: 'project_deleted',
//       projectId: projectId,
//       timestamp: new Date().toISOString()
//     });
    
//     res.json({ success: true });
//   } catch (error: any) {
//     console.error('‚ùå Error deleting project:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Get files for a project
// app.get('/api/files', async (req, res) => {
//   try {
//     const { projectId } = req.query;
    
//     if (!projectId) {
//       return res.status(400).json({ error: 'Project ID is required' });
//     }

//     console.log('üìÅ Fetching files for project:', projectId);
    
//     const projectFiles = await db.query.files.findMany({
//       where: eq(files.projectId, projectId as string),
//       orderBy: (files, { asc }) => [asc(files.path)]
//     });
    
//     console.log(`üìä Found ${projectFiles.length} files`);
//     res.json(projectFiles);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching files:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Get specific file content
// app.get('/api/files/:projectId', async (req, res) => {
//   try {
//     const { projectId } = req.params;
//     const { filePath } = req.query;
    
//     console.log('üìÑ Fetching file:', filePath, 'from project:', projectId);
    
//     const file = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, filePath as string)
//       )
//     });
    
//     if (!file) {
//       return res.status(404).json({ error: 'File not found' });
//     }
    
//     res.json(file);
//   } catch (error: any) {
//     console.error('‚ùå Error fetching file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// // Save/create file
// app.post('/api/files', async (req, res) => {
//   try {
//     const { projectId, path: filePath, content } = req.body;
//     console.log('üíæ Saving file:', filePath, 'to project:', projectId);
    
//     // Check if file exists
//     const existingFile = await db.query.files.findFirst({
//       where: and(
//         eq(files.projectId, projectId),
//         eq(files.path, filePath)
//       )
//     });

//     if (existingFile) {
//       // Update existing file
//       await db.update(files)
//         .set({ 
//           content,
//           updatedAt: new Date()
//         })
//         .where(eq(files.id, existingFile.id));
//     } else {
//       // Create new file
//       await db.insert(files).values({
//         id: crypto.randomUUID(),
//         projectId,
//         path: filePath,
//         content: content || '',
//         createdAt: new Date(),
//         updatedAt: new Date()
//       } as any);
//     }

//     // Broadcast file change to WebSocket clients
//     broadcastToProject(projectId, {
//       type: 'file_update',
//       projectId,
//       filePath,
//       source: 'dyad',
//       timestamp: new Date().toISOString()
//     });

//     console.log(`‚úÖ Saved file: ${filePath}`);
//     res.json({ success: true });
//   } catch (error: any) {
//     console.error('‚ùå Error saving file:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// async function handleFileChange(data: any) {
//   // Update file in database if needed
//   if (data.filePath && data.content !== undefined) {
//     try {
//       await db.update(files)
//         .set({ 
//           content: data.content,
//           updatedAt: new Date()
//         })
//         .where(and(
//           eq(files.projectId, data.projectId),
//           eq(files.path, data.filePath)
//         ));
//     } catch (error) {
//       console.error('‚ùå Error updating file from change event:', error);
//     }
//   }
// }

// function detectFramework(files: any[]): string {
//   if (!files || !Array.isArray(files)) return 'react';
  
//   const fileNames = files.map(f => f.path || f.name || '').join(' ').toLowerCase();
  
//   if (fileNames.includes('package.json')) {
//     const packageFile = files.find(f => (f.path || f.name || '').includes('package.json'));
//     if (packageFile && packageFile.content) {
//       try {
//         const packageJson = JSON.parse(packageFile.content);
//         if (packageJson.dependencies) {
//           if (packageJson.dependencies['@angular/core']) return 'angular';
//           if (packageJson.dependencies['vue']) return 'vue';
//           if (packageJson.dependencies['svelte']) return 'svelte';
//           if (packageJson.dependencies['react']) return 'react';
//         }
//       } catch (e) {
//         // Invalid JSON, continue with heuristics
//       }
//     }
//   }
  
//   if (fileNames.includes('.vue')) return 'vue';
//   if (fileNames.includes('.svelte')) return 'svelte';
//   if (fileNames.includes('angular.json')) return 'angular';
//   if (fileNames.includes('.jsx') || fileNames.includes('.tsx')) return 'react';
  
//   return 'react'; // Default
// }

// function getFileExtension(filePath: string): string {
//   const ext = path.extname(filePath).toLowerCase();
//   const extMap: { [key: string]: string } = {
//     '.js': 'javascript',
//     '.jsx': 'jsx',
//     '.ts': 'typescript',
//     '.tsx': 'tsx',
//     '.css': 'css',
//     '.scss': 'scss',
//     '.sass': 'sass',
//     '.html': 'html',
//     '.json': 'json',
//     '.md': 'markdown',
//     '.py': 'python',
//     '.php': 'php',
//     '.java': 'java',
//     '.cpp': 'cpp',
//     '.c': 'c',
//     '.vue': 'vue',
//     '.svelte': 'svelte'
//   };
//   return extMap[ext] || 'text';
// }

// // Update the cleanup interval to use the fixed function
// setInterval(cleanupInactiveConnections, 60000); // Check every minute

// // Initialize database and start server
// async function startServer() {
//   try {
//     await initializeDatabase();
//     console.log('üìä Database initialized successfully');
    
//     server.listen(PORT, () => {
//       console.log(`üöÄ Dyad server running on port ${PORT}`);
//       console.log(`üîå WebSocket server ready for connections`);
//       console.log(`ü§ñ Ollama integration: ${OLLAMA_BASE_URL}`);
//       console.log(`‚ö° Bolt.diy integration: ${BOLT_BASE_URL}`);
//     });
//   } catch (error) {
//     console.error('‚ùå Failed to start server:', error);
//     process.exit(1);
//   }
// }

// startServer();